{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CLI_Test \"It mostly works\" \u2122\u00a9\u00ae Version 0.0.0 Short description Table of Contents Requirements Downloading Installing Usage Uninstalling Documentation Notes Requirements Python 3.10+ Downloading There are two ways to get the code: Download the latest release (the 'Source code (zip)' file should work an all platforms). Or you can clone the git repo to get the latest (and often broken) code from the main branch: $ git clone https://github.com/cyclopticnerve/CLI_Test Installing If you downloaded the zip file, extract it and go to the 'install' directory: $ cd ~/Downloads/CLI_Test-<version>/install where \\<version> is the version number of the file you downloaded. If you cloned the repo, just go to the 'install' directory: $ cd ~/Downloads/CLI_Test/install Either way, run the install script: $ ./install.py Usage blah blah blah Uninstalling Go to the source folder for CLI_Test and run the uninstaller: $ cd ~/.local/share/cli_test/uninstall $ ./uninstall.py Documentation See the documentation Notes blah blah blah -)","title":"Home"},{"location":"#cli_test","text":"","title":"CLI_Test"},{"location":"#it-mostly-works-tm","text":"Version 0.0.0 Short description","title":"\"It mostly works\" \u2122\u00a9\u00ae"},{"location":"#table-of-contents","text":"Requirements Downloading Installing Usage Uninstalling Documentation Notes","title":"Table of Contents"},{"location":"#requirements","text":"Python 3.10+","title":"Requirements"},{"location":"#downloading","text":"There are two ways to get the code: Download the latest release (the 'Source code (zip)' file should work an all platforms). Or you can clone the git repo to get the latest (and often broken) code from the main branch: $ git clone https://github.com/cyclopticnerve/CLI_Test","title":"Downloading"},{"location":"#installing","text":"If you downloaded the zip file, extract it and go to the 'install' directory: $ cd ~/Downloads/CLI_Test-<version>/install where \\<version> is the version number of the file you downloaded. If you cloned the repo, just go to the 'install' directory: $ cd ~/Downloads/CLI_Test/install Either way, run the install script: $ ./install.py","title":"Installing"},{"location":"#usage","text":"blah blah blah","title":"Usage"},{"location":"#uninstalling","text":"Go to the source folder for CLI_Test and run the uninstaller: $ cd ~/.local/share/cli_test/uninstall $ ./uninstall.py","title":"Uninstalling"},{"location":"#documentation","text":"See the documentation","title":"Documentation"},{"location":"#notes","text":"blah blah blah -)","title":"Notes"},{"location":"API/bin/cli_test/","text":"cli_test.py The main file that runs the program This file is executable and can be called from the terminal like: foo@bar:~$ cli_test [cmd line] when placed in a folder that is in the default $PATH, ie: /usr/bin ~/.local/bin etc. (The extension will be removed by the installer) All command line options will be passed to the main class, usually located at ~/.local/share/cli_test/src/cli_test.py. Typical usage is show in the main() method. CliTest The entry point class, responsible for launching the program Public methods main: The main method of the program This class starts the program from the command line when it is installed in directories that are defined in the $PATH variable. These are places like /usr/bin, ~/.local/bin, etc. and can be called from the command line regardless of the current working directory. It is basically a \"bootstrap\" file, activating the venv and calling the main program. Source code in bin/cli_test.py class CliTest: \"\"\" The entry point class, responsible for launching the program Public methods: main: The main method of the program This class starts the program from the command line when it is installed in directories that are defined in the $PATH variable. These are places like /usr/bin, ~/.local/bin, etc. and can be called from the command line regardless of the current working directory. It is basically a \"bootstrap\" file, activating the venv and calling the main program. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # find path to prj/lib P_DIR_PRJ = Path.home() / \".local/share/cli_test\" # commands to run S_CMD_ACTIVATE = \". .venv-cli_test/bin/activate\" S_CMD_RUN = \"./src/cli_test.py\" S_CMD_RUN_ARGS = \"{} {}\" # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. It then calls the real main module, located in the install dir. \"\"\" # ---------------------------------------------------------------------- # get args args = sys.argv # remove our path args = args[1:] # quote any args with spaces args = [f'\"{item}\"' if \" \" in item else item for item in args] # put args back together with spaces args = \" \".join(args) # def cmd line - no args src_run = self.S_CMD_RUN # add args if present if len(args) > 0: src_run = self.S_CMD_RUN_ARGS.format(self.S_CMD_RUN, args) # ---------------------------------------------------------------------- # build cmd cmd = ( # cd to inst f\"cd {self.P_DIR_PRJ};\" # activate venv f\"{self.S_CMD_ACTIVATE};\" # call src w/ args f\"{src_run}\" ) # run cmd try: subprocess.run(cmd, shell=True, check=True) except subprocess.CalledProcessError: print(\"error\") main() The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. It then calls the real main module, located in the install dir. Source code in bin/cli_test.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. It then calls the real main module, located in the install dir. \"\"\" # ---------------------------------------------------------------------- # get args args = sys.argv # remove our path args = args[1:] # quote any args with spaces args = [f'\"{item}\"' if \" \" in item else item for item in args] # put args back together with spaces args = \" \".join(args) # def cmd line - no args src_run = self.S_CMD_RUN # add args if present if len(args) > 0: src_run = self.S_CMD_RUN_ARGS.format(self.S_CMD_RUN, args) # ---------------------------------------------------------------------- # build cmd cmd = ( # cd to inst f\"cd {self.P_DIR_PRJ};\" # activate venv f\"{self.S_CMD_ACTIVATE};\" # call src w/ args f\"{src_run}\" ) # run cmd try: subprocess.run(cmd, shell=True, check=True) except subprocess.CalledProcessError: print(\"error\")","title":"cli_test.py"},{"location":"API/bin/cli_test/#cli_testpy","text":"The main file that runs the program This file is executable and can be called from the terminal like: foo@bar:~$ cli_test [cmd line] when placed in a folder that is in the default $PATH, ie: /usr/bin ~/.local/bin etc. (The extension will be removed by the installer) All command line options will be passed to the main class, usually located at ~/.local/share/cli_test/src/cli_test.py. Typical usage is show in the main() method.","title":"cli_test.py"},{"location":"API/bin/cli_test/#bin.cli_test.CliTest","text":"The entry point class, responsible for launching the program Public methods main: The main method of the program This class starts the program from the command line when it is installed in directories that are defined in the $PATH variable. These are places like /usr/bin, ~/.local/bin, etc. and can be called from the command line regardless of the current working directory. It is basically a \"bootstrap\" file, activating the venv and calling the main program. Source code in bin/cli_test.py class CliTest: \"\"\" The entry point class, responsible for launching the program Public methods: main: The main method of the program This class starts the program from the command line when it is installed in directories that are defined in the $PATH variable. These are places like /usr/bin, ~/.local/bin, etc. and can be called from the command line regardless of the current working directory. It is basically a \"bootstrap\" file, activating the venv and calling the main program. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # find path to prj/lib P_DIR_PRJ = Path.home() / \".local/share/cli_test\" # commands to run S_CMD_ACTIVATE = \". .venv-cli_test/bin/activate\" S_CMD_RUN = \"./src/cli_test.py\" S_CMD_RUN_ARGS = \"{} {}\" # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. It then calls the real main module, located in the install dir. \"\"\" # ---------------------------------------------------------------------- # get args args = sys.argv # remove our path args = args[1:] # quote any args with spaces args = [f'\"{item}\"' if \" \" in item else item for item in args] # put args back together with spaces args = \" \".join(args) # def cmd line - no args src_run = self.S_CMD_RUN # add args if present if len(args) > 0: src_run = self.S_CMD_RUN_ARGS.format(self.S_CMD_RUN, args) # ---------------------------------------------------------------------- # build cmd cmd = ( # cd to inst f\"cd {self.P_DIR_PRJ};\" # activate venv f\"{self.S_CMD_ACTIVATE};\" # call src w/ args f\"{src_run}\" ) # run cmd try: subprocess.run(cmd, shell=True, check=True) except subprocess.CalledProcessError: print(\"error\")","title":"CliTest"},{"location":"API/bin/cli_test/#bin.cli_test.CliTest.main","text":"The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. It then calls the real main module, located in the install dir. Source code in bin/cli_test.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. It then calls the real main module, located in the install dir. \"\"\" # ---------------------------------------------------------------------- # get args args = sys.argv # remove our path args = args[1:] # quote any args with spaces args = [f'\"{item}\"' if \" \" in item else item for item in args] # put args back together with spaces args = \" \".join(args) # def cmd line - no args src_run = self.S_CMD_RUN # add args if present if len(args) > 0: src_run = self.S_CMD_RUN_ARGS.format(self.S_CMD_RUN, args) # ---------------------------------------------------------------------- # build cmd cmd = ( # cd to inst f\"cd {self.P_DIR_PRJ};\" # activate venv f\"{self.S_CMD_ACTIVATE};\" # call src w/ args f\"{src_run}\" ) # run cmd try: subprocess.run(cmd, shell=True, check=True) except subprocess.CalledProcessError: print(\"error\")","title":"main"},{"location":"API/install/install/","text":"install.py The install script for this project THis module installs the project, copying its files and folders to the appropriate locations on the user's computer. This file is real ugly b/c we can't access the venv, so we do it manually. CNFormatter Bases: RawTextHelpFormatter , RawDescriptionHelpFormatter A dummy class to combine multiple argparse formatters Parameters: Name Type Description Default RawTextHelpFormatter Maintains whitespace for all sorts of help text, required RawDescriptionHelpFormatter Indicates that description and epilog are required A dummy class to combine multiple argparse formatters. Source code in install/install.py class CNFormatter( argparse.RawTextHelpFormatter, argparse.RawDescriptionHelpFormatter ): \"\"\" A dummy class to combine multiple argparse formatters Args: RawTextHelpFormatter: Maintains whitespace for all sorts of help text, including argument descriptions. RawDescriptionHelpFormatter: Indicates that description and epilog are already correctly formatted and should not be line-wrapped. A dummy class to combine multiple argparse formatters. \"\"\" CNInstall The class to use for installing a PyPlate program This class performs the install operation. Source code in install/install.py class CNInstall: \"\"\" The class to use for installing a PyPlate program This class performs the install operation. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # keys S_KEY_INST_NAME = \"INST_NAME\" S_KEY_INST_VER = \"INST_VER\" S_KEY_INST_DESK = \"INST_DESK\" S_KEY_INST_CONT = \"INST_CONT\" # short description S_PP_SHORT_DESC = \"Short description\" # version string S_PP_VERSION = \"0.0.2-rc1+20250823\" # debug option strings S_ARG_DRY_OPTION = \"-d\" S_ARG_DRY_ACTION = \"store_true\" S_ARG_DRY_DEST = \"DRY_DEST\" # I18N help string for debug cmd line option S_ARG_DRY_HELP = _(\"enable dry run mode\") # config option strings S_ARG_HLP_OPTION = \"-h\" S_ARG_HLP_ACTION = \"store_true\" S_ARG_HLP_DEST = \"HLP_DEST\" # I18N: help option help S_ARG_HLP_HELP = _(\"show this help message and exit\") # about string (to be set by subclass) S_ABOUT = ( \"\\n\" \"CLI_Test\\n\" f\"{S_PP_SHORT_DESC}\\n\" f\"{S_PP_VERSION}\\n\" \"https://github.com/cyclopticnerve/CLI_Test\\n\" ) # I18N if using argparse, add help at end of about S_ABOUT_HELP = _(\"Use -h for help\") # cmd line instructions string S_EPILOG = \"\" # -------------------------------------------------------------------------- # messages # NB: format params are prog_name and prog_version # I18N: install the program S_MSG_INST_START = _(\"Installing {} Version {}\") # NB: format param is prog_name # I18N: done installing S_MSG_INST_END = _(\"{} installed\") # I18N: done with step S_MSG_DONE = _(\"Done\") # I18N: step failed S_MSG_FAIL = _(\"Fail\") # I18N: show the copy step S_MSG_COPY_START = _(\"Copying files... \") # I18N: show the venv step S_MSG_VENV_START = _(\"Making venv folder... \") # I18N: show the reqs step S_MSG_REQS_START = _(\"Installing requirements... \") # I18N: show desktop step S_MSG_DSK_START = _(\"Fixing .desktop file... \") # I18N: install aborted S_MSG_ABORT = _(\"Installation aborted\") # questions # I18N: answer yes S_ASK_YES = _(\"y\") # I18N: answer no S_ASK_NO = _(\"n\") # I18N: ask to overwrite same version S_ASK_VER_SAME = _(\"The current version of this program is already \\ installed.\\nDo you want to overwrite?\" ) # I18N: ask to overwrite newer version S_ASK_VER_OLDER = _(\"A newer version of this program is currently \\ installed.\\nDo you want to overwrite?\" ) # errors # NB: format param is file path # I18N: config file not found S_ERR_NOT_FOUND = _(\"File {} not found\") # NB: format param is file path # I18N: config file is not valid json S_ERR_NOT_JSON = _(\"File {} is not a JSON file\") # I18N: version numbers invalid S_ERR_VERSION = _(\"One or both version numbers are invalid\") # NB: format param is source path # I18N: src path invalid S_ERR_SRC_PATH = _(\"Source path can not be {}\") # NB: format param is dest path # I18N: dst path invalid S_ERR_DST_PATH = _(\"Destination path can not be {}\") # dry run messages S_DRY_VENV = \"\\nvenv cmd:\" S_DRY_REQS = \"\\nreqs cmd:\" # NB: format params are source and destination file/dir S_DRY_COPY = \"\\ncopy\\n{}\\nto\\n{}\" # NB: format param is path to icon S_DRY_DESK_ICON = \"set desktop icon: {}\" # commands # NB: format param is dir_venv S_CMD_CREATE = \"python -m venv {}\" # NB: format params are path to prj, path to venv, and path to reqs file S_CMD_INSTALL = \"cd {};. {}/bin/activate;python -m pip install -r {}\" # regex for adding user's home to icon path R_ICON_SCH = r\"^(Icon=)(.*)$\" R_ICON_REP = r\"\\g<1>{}\" # Icon=<home/__PP_IMG_DESK__> # ------------------------------------------------------------------------------ # version check results S_VER_OLDER = -1 S_VER_SAME = 0 S_VER_NEWER = 1 S_VER_ERROR = -2 # regex to compare version numbers R_VERSION_VALID = ( r\"^\" r\"(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\" r\"(?:-(\" r\"(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)\" r\"(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*\" r\"))?\" r\"(?:\\+(\" r\"[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*\" r\"))?\" r\"$\" ) R_VERSION_GROUP_MAJ = 1 R_VERSION_GROUP_MIN = 2 R_VERSION_GROUP_REV = 3 R_VERSION_GROUP_PRE = 4 R_VERSION_GROUP_META = 5 # -------------------------------------------------------------------------- # Class methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the class # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set arg properties self._dict_args = {} self._dry_run = False # project stuff # NB: set to path objects to avoid comparing to None self._dir_assets = Path() self._dir_usr_inst = Path() self._path_cfg_inst = Path() self._path_cfg_uninst = Path() self._dir_venv = Path() self._path_reqs = Path() self._file_desk = Path() self._file_desk_icon = Path() # config stuff self._dict_cfg = {} # cmd line stuff # NB: placeholder to avoid comparing to None self._parser = argparse.ArgumentParser() # -------------------------------------------------------------------------- # Install the program # -------------------------------------------------------------------------- def main( self, dir_assets, dir_usr_inst, path_cfg_inst, path_cfg_uninst, dir_venv, path_reqs, file_desk=None, file_desk_icon=None, ): \"\"\" Install the program Args: dir_assets: Path to the assets folder where all of the program files are put in dist. This is the base source path to use when copying files to the user's computer dir_usr_inst: The program's install folder in which to place files path_cfg_inst: Path to the file that contains the current install dict info path_cfg_uninst: Path to the currently installed program's uninstall dict info dir_venv: The path to the venv folder to create path_reqs: Path to the requirements.txt file to add requirements to the venv file_desk: Path to the .desktop file (if GUI) (default: None) file_desk_icon: Path to the .desktop file icon (if GUI) (default: None) Runs the install operation. \"\"\" # set props from params if dir_assets: dir_assets = Path(dir_assets) if not dir_assets.is_absolute(): # make abs rel to self dir_assets = P_DIR_PRJ / dir_assets self._dir_assets = dir_assets if dir_usr_inst: dir_usr_inst = Path(dir_usr_inst) if not dir_usr_inst.is_absolute(): # make abs rel to self dir_usr_inst = self._dir_assets / dir_usr_inst self._dir_usr_inst = dir_usr_inst if path_cfg_inst: path_cfg_inst = Path(path_cfg_inst) if not path_cfg_inst.is_absolute(): # make abs rel to self path_cfg_inst = self._dir_assets / path_cfg_inst self._path_cfg_inst = path_cfg_inst if path_cfg_uninst: path_cfg_uninst = Path(path_cfg_uninst) if not path_cfg_uninst.is_absolute(): # make abs rel to self path_cfg_uninst = self._dir_assets / path_cfg_uninst self._path_cfg_uninst = path_cfg_uninst if dir_venv: dir_venv = Path(dir_venv) if not dir_venv.is_absolute(): # make abs rel to self dir_venv = self._dir_assets / dir_venv self._dir_venv = dir_venv if path_reqs: path_reqs = Path(path_reqs) if not path_reqs.is_absolute(): # make abs rel to self path_reqs = self._dir_assets / path_reqs self._path_reqs = path_reqs if file_desk: file_desk = Path(file_desk) if not file_desk.is_absolute(): # make abs rel to self file_desk = self._dir_assets / file_desk self._file_desk = file_desk if file_desk_icon: file_desk_icon = Path(file_desk_icon) if not file_desk_icon.is_absolute(): # make abs rel to self file_desk_icon = self._dir_assets / file_desk_icon self._file_desk_icon = file_desk_icon # ---------------------------------------------------------------------- # do setup self._setup() # parse cmd line and get args self._do_cmd_line() # get prj info from cfg self._get_project_info() # check for existing/old version self._check_version() # make the venv on the user's comp self._make_venv() # install reqs self._install_reqs() # fix desktop file if present self._fix_desktop_file() # move content self._install_content() # wind down self._teardown() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main() # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. \"\"\" # print default about text print(self.S_ABOUT) # create a parser object in case we need it self._parser = argparse.ArgumentParser( add_help=False, epilog=self.S_EPILOG, formatter_class=CNFormatter, ) # add help text to about block print(self.S_ABOUT_HELP) # add help option self._parser.add_argument( self.S_ARG_HLP_OPTION, dest=self.S_ARG_HLP_DEST, help=self.S_ARG_HLP_HELP, action=self.S_ARG_HLP_ACTION, ) # add dry run option self._parser.add_argument( self.S_ARG_DRY_OPTION, dest=self.S_ARG_DRY_DEST, help=self.S_ARG_DRY_HELP, action=self.S_ARG_DRY_ACTION, ) # -------------------------------------------------------------------------- # Parse the arguments from the command line # -------------------------------------------------------------------------- def _do_cmd_line(self): \"\"\" Parse the arguments from the command line Parse the arguments from the command line, after the parser has been set up. \"\"\" # get namespace object args = self._parser.parse_args() # convert namespace to dict self._dict_args = vars(args) # if -h passed, this will print and exit if self._dict_args.get(self.S_ARG_HLP_DEST, False): self._parser.print_help() sys.exit() # no -h, print epilog print(self.S_EPILOG) # ---------------------------------------------------------------------- # get the args self._dry_run = self._dict_args.get(self.S_ARG_DRY_DEST, False) # -------------------------------------------------------------------------- # Get project info # -------------------------------------------------------------------------- def _get_project_info(self): \"\"\" Get project info Get the install info from the config file. \"\"\" # get project info self._dict_cfg = self._get_dict_from_file(self._path_cfg_inst) # get prg name/version prog_name = self._dict_cfg[self.S_KEY_INST_NAME] prog_version = self._dict_cfg[self.S_KEY_INST_VER] # print start msg print(self.S_MSG_INST_START.format(prog_name, prog_version)) # -------------------------------------------------------------------------- # Check version info # -------------------------------------------------------------------------- def _check_version(self): \"\"\" Check version info Get the version info from the new config file and the old config file (if present), compare the two values, and either continue or abort. \"\"\" # if we did pass an old conf, it must exist (if it doesn't, this could # be the first install but we will want to check on later updates) if self._path_cfg_uninst and Path(self._path_cfg_uninst).exists(): # get info from old cfg dict_cfg_old = self._get_dict_from_file(self._path_cfg_uninst) # check versions ver_old = dict_cfg_old[self.S_KEY_INST_VER] ver_new = self._dict_cfg[self.S_KEY_INST_VER] # do the compare and get S_VER__OLDER, S_VER_SAME, S_VER_NEWER res = self._comp_sem_ver(ver_old, ver_new) # same version is installed if res == self.S_VER_SAME: # ask to install same version str_ask = self._dialog( self.S_ASK_VER_SAME, [self.S_ASK_YES, self.S_ASK_NO], self.S_ASK_NO, ) # user hit enter or typed anything else except \"y\" if str_ask == self.S_ASK_NO: print(self.S_MSG_ABORT) sys.exit() # newer version is installed elif res == self.S_VER_OLDER: # ask to install old version over newer str_ask = self._dialog( self.S_ASK_VER_OLDER, [self.S_ASK_YES, self.S_ASK_NO], self.S_ASK_NO, ) # user hit enter or typed anything else except \"y\" if str_ask == self.S_ASK_NO: print(self.S_MSG_ABORT) sys.exit() # -------------------------------------------------------------------------- # Make venv for this program on user's computer # -------------------------------------------------------------------------- def _make_venv(self): \"\"\" Make venv for this program on user's computer Raises: subprocess.CalledProcessError if the venv creation fails Makes a .venv-XXX folder on the user's computer. \"\"\" # show progress print(self.S_MSG_VENV_START, flush=True, end=\"\") # the command to create a venv cmd = self.S_CMD_CREATE.format(self._dir_venv) # if it's a dry run, don't make venv if self._dry_run: print(self.S_DRY_VENV, cmd) print(self.S_MSG_DONE) return # the cmd to create the venv try: subprocess.run(cmd, shell=True, check=True) print(self.S_MSG_DONE) except Exception as e: print(self.S_MSG_FAIL) raise e # -------------------------------------------------------------------------- # Install requirements.txt # -------------------------------------------------------------------------- def _install_reqs(self): \"\"\" Install requirements.txt Raises: subprocess.CalledProcessError if the reqs install fails Installs the contents of a requirements.txt file into the program's venv. \"\"\" # show progress print(self.S_MSG_REQS_START, end=\"\", flush=True) # the command to install packages to venv from reqs cmd = self.S_CMD_INSTALL.format( self._dir_venv.parent, self._dir_venv.name, self._path_reqs ) # if it's a dry run, don't install if self._dry_run: print(self.S_DRY_REQS, cmd) print(self.S_MSG_DONE) return # the cmd to install the reqs try: # NB: hide output subprocess.run( cmd, shell=True, check=True, stdout=subprocess.DEVNULL ) print(self.S_MSG_DONE) except Exception as e: print(self.S_MSG_FAIL) raise e # -------------------------------------------------------------------------- # Fix .desktop file, for paths and such # -------------------------------------------------------------------------- def _fix_desktop_file(self): \"\"\" Fix .desktop file, for paths and such Raises: OSError if one of both of the files does not exist Fixes entries in the .desktop file (absolute paths, etc.) Currently only fixes absolute path to icon. \"\"\" # make sure we even care about desktop use_desk = self._dict_cfg.get(self.S_KEY_INST_DESK, False) if not use_desk: return # check both files for None and exist if not self._file_desk or not self._file_desk.exists(): raise OSError(self.S_ERR_NOT_FOUND.format(self._file_desk)) if not self._file_desk_icon or not self._file_desk_icon.exists(): raise OSError(self.S_ERR_NOT_FOUND.format(self._file_desk_icon)) # print info print(self.S_MSG_DSK_START, end=\"\", flush=True) # don't mess with file if self._dry_run: print(self.S_DRY_DESK_ICON.format(self._file_desk_icon)) print(self.S_MSG_DONE) return # open file text = \"\" with open(self._file_desk, \"r\", encoding=\"UTF-8\") as a_file: text = a_file.read() # find icon line and fix res = re.search(self.R_ICON_SCH, text, flags=re.M) if res: # get user's home and path to icon rel to prj path_icon = Path.home() / self._file_desk_icon # fix abs path to icon r_icon_rep = self.R_ICON_REP.format(path_icon) text = re.sub(self.R_ICON_SCH, r_icon_rep, text, flags=re.M) # ------------------------------------------------------------------ # write fixed text back to file with open(self._file_desk, \"w\", encoding=\"UTF-8\") as a_file: a_file.write(text) # show some info print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Copy source files/folders # -------------------------------------------------------------------------- def _install_content(self): \"\"\" Copy source files/folders This method copies files and folders from the assets folder of the source to their final locations in the user's folder structure. \"\"\" # show some info print(self.S_MSG_COPY_START, flush=True, end=\"\") # content list from dict content = self._dict_cfg.get(self.S_KEY_INST_CONT, {}) # for each key, value for k, v in content.items(): # get full paths of source / destination src = self._dir_assets / k dst = Path.home() / v / src.name # debug may omit certain assets if not src.exists(): continue # check for dry run if self._dry_run: print(self.S_DRY_COPY.format(src, dst)) else: # if the source is a dir if src.is_dir(): shutil.copytree(src, dst, dirs_exist_ok=True) # if the src is a file else: shutil.copy(src, dst) # show some info print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Boilerplate to use at the end of main # -------------------------------------------------------------------------- def _teardown(self): \"\"\" Boilerplate to use at the end of main Perform some mundane stuff like saving config files. \"\"\" # just show we are done prog_name = self._dict_cfg[self.S_KEY_INST_NAME] print(self.S_MSG_INST_END.format(prog_name)) # -------------------------------------------------------------------------- # These are the minor steps, called from major steps for support # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Get a dict from a file # -------------------------------------------------------------------------- def _get_dict_from_file(self, a_file): \"\"\" Get a dict from a file Args: a_file: The file to load the dict from Raises: OSError if the file cannot be found or is not a valid JSON file Returns: The dict found in the file Get a dict from a file, checking if the file exists and is a valid JSON file \"\"\" # default result a_dict = {} # get dict from file try: with open(a_file, \"r\", encoding=\"UTF-8\") as a_file: a_dict = json.load(a_file) # file not found except FileNotFoundError as e: raise OSError(self.S_ERR_NOT_FOUND.format(a_file)) from e # not valid json in file except json.JSONDecodeError as e: raise OSError(self.S_ERR_NOT_JSON.format(a_file)) from e # return result return a_dict # -------------------------------------------------------------------------- # Create a dialog-like question and return the result # -------------------------------------------------------------------------- def _dialog( self, message, buttons, default=\"\", btn_sep=\"/\", msg_fmt=\"{} [{}]: \" ): \"\"\" Create a dialog-like question and return the result Args: message: The message to display buttons: List of single char answers to the question default: The button item to return when the user presses Enter at \\ the question (default: \"\") btn_sep: Char to use to separate button items msg_fmt: Format string to present message/buttons to the user Returns: String that matches button (or empty string if entered option is not in button list) This method returns the string entered on the command line in response to a question. If the entered option does not match any of the buttons, a blank string is returned. If you set a default and the option entered is just the Return key, the default string will be returned. If no default is present, the entered string must match one of the buttons array values. All returned values are lowercased. The question will be repeatedly printed to the screen until a valid entry is made. Note that if default == \"\", pressing Enter is not considered a valid entry. \"\"\" # make all params lowercase buttons = [item.lower() for item in buttons] default = default.lower() # ---------------------------------------------------------------------- # if we passes a default if default != \"\": # find the default if not default in buttons: # not found, add at end of buttons buttons.append(default) # upper case it buttons[buttons.index(default)] = default.upper() # ---------------------------------------------------------------------- # add buttons to message btns_all = btn_sep.join(buttons) str_fmt = msg_fmt.format(message, btns_all) # lower everything again for compare buttons = [item.lower() for item in buttons] # ---------------------------------------------------------------------- while True: # ask the question, get the result inp = input(str_fmt) inp = inp.lower() # # no input (empty) if inp == \"\" and default != \"\": return default # input a button if inp in buttons: return inp # ------------------------------------------------------------------------------ # Compare two semantic versions # ------------------------------------------------------------------------------ def _comp_sem_ver(self, ver_old, ver_new): \"\"\" Compare two semantic versions Args: ver_old: The old version to compare ver_new: The new version to compare Returns: An integer showing the relationship between the two version Compare two semantic versions \"\"\" # sanity checks if not ver_old or ver_old == \"\": return self.S_VER_ERROR if not ver_new or ver_new == \"\": return self.S_VER_ERROR if ver_old == ver_new: return self.S_VER_SAME # -------------------------------------------------------------------------- # compare version string parts (only x.x.x) res_old = re.search(self.R_VERSION_VALID, ver_old) res_new = re.search(self.R_VERSION_VALID, ver_new) # if either version string is None if not res_old or not res_new: return self.S_VER_ERROR # make a list of groups to check lst_groups = [ self.R_VERSION_GROUP_MAJ, self.R_VERSION_GROUP_MIN, self.R_VERSION_GROUP_REV, ] # for each part as int for group in lst_groups: old_val = int(res_old.group(group)) new_val = int(res_new.group(group)) # slide out at the first difference if old_val < new_val: return self.S_VER_NEWER if old_val > new_val: return self.S_VER_OLDER # -------------------------------------------------------------------------- # still going, check pre pre_old = res_old.group(self.R_VERSION_GROUP_PRE) pre_new = res_new.group(self.R_VERSION_GROUP_PRE) # simple pre rule compare if not pre_old and pre_new: return self.S_VER_OLDER if pre_old and not pre_new: return self.S_VER_NEWER if not pre_old and not pre_new: return self.S_VER_SAME # -------------------------------------------------------------------------- # if pre_old and pre_new: # split pre on dots lst_pre_old = pre_old.split(\".\") lst_pre_new = pre_new.split(\".\") # get number of parts len_pre_old = len(lst_pre_old) len_pre_new = len(lst_pre_new) # get shorter of two shortest = len_pre_old if len_pre_old <= len_pre_new else len_pre_new # for each part in shortest for index in range(shortest): # get each value at position old_val = lst_pre_old[index] new_val = lst_pre_new[index] # 1. both numbers if old_val.isdigit() and new_val.isdigit(): tmp_old_val = int(old_val) tmp_new_val = int(new_val) # slide out at the first difference if tmp_old_val > tmp_new_val: return self.S_VER_OLDER if tmp_old_val < tmp_new_val: return self.S_VER_NEWER # 2. both alphanumeric if not old_val.isdigit() and not new_val.isdigit(): lst_alpha = [old_val, new_val] lst_alpha.sort() idx_old = lst_alpha.index(old_val) idx_new = lst_alpha.index(new_val) if idx_old > idx_new: return self.S_VER_OLDER if idx_old < idx_new: return self.S_VER_NEWER # 3 num vs alphanumeric if old_val.isdigit() and not new_val.isdigit(): return self.S_VER_OLDER if not old_val.isdigit() and new_val.isdigit(): return self.S_VER_NEWER # 4 len if len_pre_old > len_pre_new: return self.S_VER_OLDER if len_pre_new > len_pre_old: return self.S_VER_NEWER # -------------------------------------------------------------------------- # error in one or both versions return self.S_VER_ERROR __init__() Initialize the class Creates a new instance of the object and initializes its properties. Source code in install/install.py def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set arg properties self._dict_args = {} self._dry_run = False # project stuff # NB: set to path objects to avoid comparing to None self._dir_assets = Path() self._dir_usr_inst = Path() self._path_cfg_inst = Path() self._path_cfg_uninst = Path() self._dir_venv = Path() self._path_reqs = Path() self._file_desk = Path() self._file_desk_icon = Path() # config stuff self._dict_cfg = {} # cmd line stuff # NB: placeholder to avoid comparing to None self._parser = argparse.ArgumentParser() main(dir_assets, dir_usr_inst, path_cfg_inst, path_cfg_uninst, dir_venv, path_reqs, file_desk=None, file_desk_icon=None) Install the program Parameters: Name Type Description Default dir_assets Path to the assets folder where all of the program required dir_usr_inst The program's install folder in which to place files required path_cfg_inst Path to the file that contains the current install required path_cfg_uninst Path to the currently installed program's required dir_venv The path to the venv folder to create required path_reqs Path to the requirements.txt file to add requirements to required file_desk Path to the .desktop file (if GUI) (default: None) None file_desk_icon Path to the .desktop file icon (if GUI) (default: None Runs the install operation. Source code in install/install.py def main( self, dir_assets, dir_usr_inst, path_cfg_inst, path_cfg_uninst, dir_venv, path_reqs, file_desk=None, file_desk_icon=None, ): \"\"\" Install the program Args: dir_assets: Path to the assets folder where all of the program files are put in dist. This is the base source path to use when copying files to the user's computer dir_usr_inst: The program's install folder in which to place files path_cfg_inst: Path to the file that contains the current install dict info path_cfg_uninst: Path to the currently installed program's uninstall dict info dir_venv: The path to the venv folder to create path_reqs: Path to the requirements.txt file to add requirements to the venv file_desk: Path to the .desktop file (if GUI) (default: None) file_desk_icon: Path to the .desktop file icon (if GUI) (default: None) Runs the install operation. \"\"\" # set props from params if dir_assets: dir_assets = Path(dir_assets) if not dir_assets.is_absolute(): # make abs rel to self dir_assets = P_DIR_PRJ / dir_assets self._dir_assets = dir_assets if dir_usr_inst: dir_usr_inst = Path(dir_usr_inst) if not dir_usr_inst.is_absolute(): # make abs rel to self dir_usr_inst = self._dir_assets / dir_usr_inst self._dir_usr_inst = dir_usr_inst if path_cfg_inst: path_cfg_inst = Path(path_cfg_inst) if not path_cfg_inst.is_absolute(): # make abs rel to self path_cfg_inst = self._dir_assets / path_cfg_inst self._path_cfg_inst = path_cfg_inst if path_cfg_uninst: path_cfg_uninst = Path(path_cfg_uninst) if not path_cfg_uninst.is_absolute(): # make abs rel to self path_cfg_uninst = self._dir_assets / path_cfg_uninst self._path_cfg_uninst = path_cfg_uninst if dir_venv: dir_venv = Path(dir_venv) if not dir_venv.is_absolute(): # make abs rel to self dir_venv = self._dir_assets / dir_venv self._dir_venv = dir_venv if path_reqs: path_reqs = Path(path_reqs) if not path_reqs.is_absolute(): # make abs rel to self path_reqs = self._dir_assets / path_reqs self._path_reqs = path_reqs if file_desk: file_desk = Path(file_desk) if not file_desk.is_absolute(): # make abs rel to self file_desk = self._dir_assets / file_desk self._file_desk = file_desk if file_desk_icon: file_desk_icon = Path(file_desk_icon) if not file_desk_icon.is_absolute(): # make abs rel to self file_desk_icon = self._dir_assets / file_desk_icon self._file_desk_icon = file_desk_icon # ---------------------------------------------------------------------- # do setup self._setup() # parse cmd line and get args self._do_cmd_line() # get prj info from cfg self._get_project_info() # check for existing/old version self._check_version() # make the venv on the user's comp self._make_venv() # install reqs self._install_reqs() # fix desktop file if present self._fix_desktop_file() # move content self._install_content() # wind down self._teardown()","title":"install.py"},{"location":"API/install/install/#installpy","text":"The install script for this project THis module installs the project, copying its files and folders to the appropriate locations on the user's computer. This file is real ugly b/c we can't access the venv, so we do it manually.","title":"install.py"},{"location":"API/install/install/#install.install.CNFormatter","text":"Bases: RawTextHelpFormatter , RawDescriptionHelpFormatter A dummy class to combine multiple argparse formatters Parameters: Name Type Description Default RawTextHelpFormatter Maintains whitespace for all sorts of help text, required RawDescriptionHelpFormatter Indicates that description and epilog are required A dummy class to combine multiple argparse formatters. Source code in install/install.py class CNFormatter( argparse.RawTextHelpFormatter, argparse.RawDescriptionHelpFormatter ): \"\"\" A dummy class to combine multiple argparse formatters Args: RawTextHelpFormatter: Maintains whitespace for all sorts of help text, including argument descriptions. RawDescriptionHelpFormatter: Indicates that description and epilog are already correctly formatted and should not be line-wrapped. A dummy class to combine multiple argparse formatters. \"\"\"","title":"CNFormatter"},{"location":"API/install/install/#install.install.CNInstall","text":"The class to use for installing a PyPlate program This class performs the install operation. Source code in install/install.py class CNInstall: \"\"\" The class to use for installing a PyPlate program This class performs the install operation. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # keys S_KEY_INST_NAME = \"INST_NAME\" S_KEY_INST_VER = \"INST_VER\" S_KEY_INST_DESK = \"INST_DESK\" S_KEY_INST_CONT = \"INST_CONT\" # short description S_PP_SHORT_DESC = \"Short description\" # version string S_PP_VERSION = \"0.0.2-rc1+20250823\" # debug option strings S_ARG_DRY_OPTION = \"-d\" S_ARG_DRY_ACTION = \"store_true\" S_ARG_DRY_DEST = \"DRY_DEST\" # I18N help string for debug cmd line option S_ARG_DRY_HELP = _(\"enable dry run mode\") # config option strings S_ARG_HLP_OPTION = \"-h\" S_ARG_HLP_ACTION = \"store_true\" S_ARG_HLP_DEST = \"HLP_DEST\" # I18N: help option help S_ARG_HLP_HELP = _(\"show this help message and exit\") # about string (to be set by subclass) S_ABOUT = ( \"\\n\" \"CLI_Test\\n\" f\"{S_PP_SHORT_DESC}\\n\" f\"{S_PP_VERSION}\\n\" \"https://github.com/cyclopticnerve/CLI_Test\\n\" ) # I18N if using argparse, add help at end of about S_ABOUT_HELP = _(\"Use -h for help\") # cmd line instructions string S_EPILOG = \"\" # -------------------------------------------------------------------------- # messages # NB: format params are prog_name and prog_version # I18N: install the program S_MSG_INST_START = _(\"Installing {} Version {}\") # NB: format param is prog_name # I18N: done installing S_MSG_INST_END = _(\"{} installed\") # I18N: done with step S_MSG_DONE = _(\"Done\") # I18N: step failed S_MSG_FAIL = _(\"Fail\") # I18N: show the copy step S_MSG_COPY_START = _(\"Copying files... \") # I18N: show the venv step S_MSG_VENV_START = _(\"Making venv folder... \") # I18N: show the reqs step S_MSG_REQS_START = _(\"Installing requirements... \") # I18N: show desktop step S_MSG_DSK_START = _(\"Fixing .desktop file... \") # I18N: install aborted S_MSG_ABORT = _(\"Installation aborted\") # questions # I18N: answer yes S_ASK_YES = _(\"y\") # I18N: answer no S_ASK_NO = _(\"n\") # I18N: ask to overwrite same version S_ASK_VER_SAME = _(\"The current version of this program is already \\ installed.\\nDo you want to overwrite?\" ) # I18N: ask to overwrite newer version S_ASK_VER_OLDER = _(\"A newer version of this program is currently \\ installed.\\nDo you want to overwrite?\" ) # errors # NB: format param is file path # I18N: config file not found S_ERR_NOT_FOUND = _(\"File {} not found\") # NB: format param is file path # I18N: config file is not valid json S_ERR_NOT_JSON = _(\"File {} is not a JSON file\") # I18N: version numbers invalid S_ERR_VERSION = _(\"One or both version numbers are invalid\") # NB: format param is source path # I18N: src path invalid S_ERR_SRC_PATH = _(\"Source path can not be {}\") # NB: format param is dest path # I18N: dst path invalid S_ERR_DST_PATH = _(\"Destination path can not be {}\") # dry run messages S_DRY_VENV = \"\\nvenv cmd:\" S_DRY_REQS = \"\\nreqs cmd:\" # NB: format params are source and destination file/dir S_DRY_COPY = \"\\ncopy\\n{}\\nto\\n{}\" # NB: format param is path to icon S_DRY_DESK_ICON = \"set desktop icon: {}\" # commands # NB: format param is dir_venv S_CMD_CREATE = \"python -m venv {}\" # NB: format params are path to prj, path to venv, and path to reqs file S_CMD_INSTALL = \"cd {};. {}/bin/activate;python -m pip install -r {}\" # regex for adding user's home to icon path R_ICON_SCH = r\"^(Icon=)(.*)$\" R_ICON_REP = r\"\\g<1>{}\" # Icon=<home/__PP_IMG_DESK__> # ------------------------------------------------------------------------------ # version check results S_VER_OLDER = -1 S_VER_SAME = 0 S_VER_NEWER = 1 S_VER_ERROR = -2 # regex to compare version numbers R_VERSION_VALID = ( r\"^\" r\"(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\" r\"(?:-(\" r\"(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)\" r\"(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*\" r\"))?\" r\"(?:\\+(\" r\"[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*\" r\"))?\" r\"$\" ) R_VERSION_GROUP_MAJ = 1 R_VERSION_GROUP_MIN = 2 R_VERSION_GROUP_REV = 3 R_VERSION_GROUP_PRE = 4 R_VERSION_GROUP_META = 5 # -------------------------------------------------------------------------- # Class methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the class # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set arg properties self._dict_args = {} self._dry_run = False # project stuff # NB: set to path objects to avoid comparing to None self._dir_assets = Path() self._dir_usr_inst = Path() self._path_cfg_inst = Path() self._path_cfg_uninst = Path() self._dir_venv = Path() self._path_reqs = Path() self._file_desk = Path() self._file_desk_icon = Path() # config stuff self._dict_cfg = {} # cmd line stuff # NB: placeholder to avoid comparing to None self._parser = argparse.ArgumentParser() # -------------------------------------------------------------------------- # Install the program # -------------------------------------------------------------------------- def main( self, dir_assets, dir_usr_inst, path_cfg_inst, path_cfg_uninst, dir_venv, path_reqs, file_desk=None, file_desk_icon=None, ): \"\"\" Install the program Args: dir_assets: Path to the assets folder where all of the program files are put in dist. This is the base source path to use when copying files to the user's computer dir_usr_inst: The program's install folder in which to place files path_cfg_inst: Path to the file that contains the current install dict info path_cfg_uninst: Path to the currently installed program's uninstall dict info dir_venv: The path to the venv folder to create path_reqs: Path to the requirements.txt file to add requirements to the venv file_desk: Path to the .desktop file (if GUI) (default: None) file_desk_icon: Path to the .desktop file icon (if GUI) (default: None) Runs the install operation. \"\"\" # set props from params if dir_assets: dir_assets = Path(dir_assets) if not dir_assets.is_absolute(): # make abs rel to self dir_assets = P_DIR_PRJ / dir_assets self._dir_assets = dir_assets if dir_usr_inst: dir_usr_inst = Path(dir_usr_inst) if not dir_usr_inst.is_absolute(): # make abs rel to self dir_usr_inst = self._dir_assets / dir_usr_inst self._dir_usr_inst = dir_usr_inst if path_cfg_inst: path_cfg_inst = Path(path_cfg_inst) if not path_cfg_inst.is_absolute(): # make abs rel to self path_cfg_inst = self._dir_assets / path_cfg_inst self._path_cfg_inst = path_cfg_inst if path_cfg_uninst: path_cfg_uninst = Path(path_cfg_uninst) if not path_cfg_uninst.is_absolute(): # make abs rel to self path_cfg_uninst = self._dir_assets / path_cfg_uninst self._path_cfg_uninst = path_cfg_uninst if dir_venv: dir_venv = Path(dir_venv) if not dir_venv.is_absolute(): # make abs rel to self dir_venv = self._dir_assets / dir_venv self._dir_venv = dir_venv if path_reqs: path_reqs = Path(path_reqs) if not path_reqs.is_absolute(): # make abs rel to self path_reqs = self._dir_assets / path_reqs self._path_reqs = path_reqs if file_desk: file_desk = Path(file_desk) if not file_desk.is_absolute(): # make abs rel to self file_desk = self._dir_assets / file_desk self._file_desk = file_desk if file_desk_icon: file_desk_icon = Path(file_desk_icon) if not file_desk_icon.is_absolute(): # make abs rel to self file_desk_icon = self._dir_assets / file_desk_icon self._file_desk_icon = file_desk_icon # ---------------------------------------------------------------------- # do setup self._setup() # parse cmd line and get args self._do_cmd_line() # get prj info from cfg self._get_project_info() # check for existing/old version self._check_version() # make the venv on the user's comp self._make_venv() # install reqs self._install_reqs() # fix desktop file if present self._fix_desktop_file() # move content self._install_content() # wind down self._teardown() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main() # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. \"\"\" # print default about text print(self.S_ABOUT) # create a parser object in case we need it self._parser = argparse.ArgumentParser( add_help=False, epilog=self.S_EPILOG, formatter_class=CNFormatter, ) # add help text to about block print(self.S_ABOUT_HELP) # add help option self._parser.add_argument( self.S_ARG_HLP_OPTION, dest=self.S_ARG_HLP_DEST, help=self.S_ARG_HLP_HELP, action=self.S_ARG_HLP_ACTION, ) # add dry run option self._parser.add_argument( self.S_ARG_DRY_OPTION, dest=self.S_ARG_DRY_DEST, help=self.S_ARG_DRY_HELP, action=self.S_ARG_DRY_ACTION, ) # -------------------------------------------------------------------------- # Parse the arguments from the command line # -------------------------------------------------------------------------- def _do_cmd_line(self): \"\"\" Parse the arguments from the command line Parse the arguments from the command line, after the parser has been set up. \"\"\" # get namespace object args = self._parser.parse_args() # convert namespace to dict self._dict_args = vars(args) # if -h passed, this will print and exit if self._dict_args.get(self.S_ARG_HLP_DEST, False): self._parser.print_help() sys.exit() # no -h, print epilog print(self.S_EPILOG) # ---------------------------------------------------------------------- # get the args self._dry_run = self._dict_args.get(self.S_ARG_DRY_DEST, False) # -------------------------------------------------------------------------- # Get project info # -------------------------------------------------------------------------- def _get_project_info(self): \"\"\" Get project info Get the install info from the config file. \"\"\" # get project info self._dict_cfg = self._get_dict_from_file(self._path_cfg_inst) # get prg name/version prog_name = self._dict_cfg[self.S_KEY_INST_NAME] prog_version = self._dict_cfg[self.S_KEY_INST_VER] # print start msg print(self.S_MSG_INST_START.format(prog_name, prog_version)) # -------------------------------------------------------------------------- # Check version info # -------------------------------------------------------------------------- def _check_version(self): \"\"\" Check version info Get the version info from the new config file and the old config file (if present), compare the two values, and either continue or abort. \"\"\" # if we did pass an old conf, it must exist (if it doesn't, this could # be the first install but we will want to check on later updates) if self._path_cfg_uninst and Path(self._path_cfg_uninst).exists(): # get info from old cfg dict_cfg_old = self._get_dict_from_file(self._path_cfg_uninst) # check versions ver_old = dict_cfg_old[self.S_KEY_INST_VER] ver_new = self._dict_cfg[self.S_KEY_INST_VER] # do the compare and get S_VER__OLDER, S_VER_SAME, S_VER_NEWER res = self._comp_sem_ver(ver_old, ver_new) # same version is installed if res == self.S_VER_SAME: # ask to install same version str_ask = self._dialog( self.S_ASK_VER_SAME, [self.S_ASK_YES, self.S_ASK_NO], self.S_ASK_NO, ) # user hit enter or typed anything else except \"y\" if str_ask == self.S_ASK_NO: print(self.S_MSG_ABORT) sys.exit() # newer version is installed elif res == self.S_VER_OLDER: # ask to install old version over newer str_ask = self._dialog( self.S_ASK_VER_OLDER, [self.S_ASK_YES, self.S_ASK_NO], self.S_ASK_NO, ) # user hit enter or typed anything else except \"y\" if str_ask == self.S_ASK_NO: print(self.S_MSG_ABORT) sys.exit() # -------------------------------------------------------------------------- # Make venv for this program on user's computer # -------------------------------------------------------------------------- def _make_venv(self): \"\"\" Make venv for this program on user's computer Raises: subprocess.CalledProcessError if the venv creation fails Makes a .venv-XXX folder on the user's computer. \"\"\" # show progress print(self.S_MSG_VENV_START, flush=True, end=\"\") # the command to create a venv cmd = self.S_CMD_CREATE.format(self._dir_venv) # if it's a dry run, don't make venv if self._dry_run: print(self.S_DRY_VENV, cmd) print(self.S_MSG_DONE) return # the cmd to create the venv try: subprocess.run(cmd, shell=True, check=True) print(self.S_MSG_DONE) except Exception as e: print(self.S_MSG_FAIL) raise e # -------------------------------------------------------------------------- # Install requirements.txt # -------------------------------------------------------------------------- def _install_reqs(self): \"\"\" Install requirements.txt Raises: subprocess.CalledProcessError if the reqs install fails Installs the contents of a requirements.txt file into the program's venv. \"\"\" # show progress print(self.S_MSG_REQS_START, end=\"\", flush=True) # the command to install packages to venv from reqs cmd = self.S_CMD_INSTALL.format( self._dir_venv.parent, self._dir_venv.name, self._path_reqs ) # if it's a dry run, don't install if self._dry_run: print(self.S_DRY_REQS, cmd) print(self.S_MSG_DONE) return # the cmd to install the reqs try: # NB: hide output subprocess.run( cmd, shell=True, check=True, stdout=subprocess.DEVNULL ) print(self.S_MSG_DONE) except Exception as e: print(self.S_MSG_FAIL) raise e # -------------------------------------------------------------------------- # Fix .desktop file, for paths and such # -------------------------------------------------------------------------- def _fix_desktop_file(self): \"\"\" Fix .desktop file, for paths and such Raises: OSError if one of both of the files does not exist Fixes entries in the .desktop file (absolute paths, etc.) Currently only fixes absolute path to icon. \"\"\" # make sure we even care about desktop use_desk = self._dict_cfg.get(self.S_KEY_INST_DESK, False) if not use_desk: return # check both files for None and exist if not self._file_desk or not self._file_desk.exists(): raise OSError(self.S_ERR_NOT_FOUND.format(self._file_desk)) if not self._file_desk_icon or not self._file_desk_icon.exists(): raise OSError(self.S_ERR_NOT_FOUND.format(self._file_desk_icon)) # print info print(self.S_MSG_DSK_START, end=\"\", flush=True) # don't mess with file if self._dry_run: print(self.S_DRY_DESK_ICON.format(self._file_desk_icon)) print(self.S_MSG_DONE) return # open file text = \"\" with open(self._file_desk, \"r\", encoding=\"UTF-8\") as a_file: text = a_file.read() # find icon line and fix res = re.search(self.R_ICON_SCH, text, flags=re.M) if res: # get user's home and path to icon rel to prj path_icon = Path.home() / self._file_desk_icon # fix abs path to icon r_icon_rep = self.R_ICON_REP.format(path_icon) text = re.sub(self.R_ICON_SCH, r_icon_rep, text, flags=re.M) # ------------------------------------------------------------------ # write fixed text back to file with open(self._file_desk, \"w\", encoding=\"UTF-8\") as a_file: a_file.write(text) # show some info print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Copy source files/folders # -------------------------------------------------------------------------- def _install_content(self): \"\"\" Copy source files/folders This method copies files and folders from the assets folder of the source to their final locations in the user's folder structure. \"\"\" # show some info print(self.S_MSG_COPY_START, flush=True, end=\"\") # content list from dict content = self._dict_cfg.get(self.S_KEY_INST_CONT, {}) # for each key, value for k, v in content.items(): # get full paths of source / destination src = self._dir_assets / k dst = Path.home() / v / src.name # debug may omit certain assets if not src.exists(): continue # check for dry run if self._dry_run: print(self.S_DRY_COPY.format(src, dst)) else: # if the source is a dir if src.is_dir(): shutil.copytree(src, dst, dirs_exist_ok=True) # if the src is a file else: shutil.copy(src, dst) # show some info print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Boilerplate to use at the end of main # -------------------------------------------------------------------------- def _teardown(self): \"\"\" Boilerplate to use at the end of main Perform some mundane stuff like saving config files. \"\"\" # just show we are done prog_name = self._dict_cfg[self.S_KEY_INST_NAME] print(self.S_MSG_INST_END.format(prog_name)) # -------------------------------------------------------------------------- # These are the minor steps, called from major steps for support # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Get a dict from a file # -------------------------------------------------------------------------- def _get_dict_from_file(self, a_file): \"\"\" Get a dict from a file Args: a_file: The file to load the dict from Raises: OSError if the file cannot be found or is not a valid JSON file Returns: The dict found in the file Get a dict from a file, checking if the file exists and is a valid JSON file \"\"\" # default result a_dict = {} # get dict from file try: with open(a_file, \"r\", encoding=\"UTF-8\") as a_file: a_dict = json.load(a_file) # file not found except FileNotFoundError as e: raise OSError(self.S_ERR_NOT_FOUND.format(a_file)) from e # not valid json in file except json.JSONDecodeError as e: raise OSError(self.S_ERR_NOT_JSON.format(a_file)) from e # return result return a_dict # -------------------------------------------------------------------------- # Create a dialog-like question and return the result # -------------------------------------------------------------------------- def _dialog( self, message, buttons, default=\"\", btn_sep=\"/\", msg_fmt=\"{} [{}]: \" ): \"\"\" Create a dialog-like question and return the result Args: message: The message to display buttons: List of single char answers to the question default: The button item to return when the user presses Enter at \\ the question (default: \"\") btn_sep: Char to use to separate button items msg_fmt: Format string to present message/buttons to the user Returns: String that matches button (or empty string if entered option is not in button list) This method returns the string entered on the command line in response to a question. If the entered option does not match any of the buttons, a blank string is returned. If you set a default and the option entered is just the Return key, the default string will be returned. If no default is present, the entered string must match one of the buttons array values. All returned values are lowercased. The question will be repeatedly printed to the screen until a valid entry is made. Note that if default == \"\", pressing Enter is not considered a valid entry. \"\"\" # make all params lowercase buttons = [item.lower() for item in buttons] default = default.lower() # ---------------------------------------------------------------------- # if we passes a default if default != \"\": # find the default if not default in buttons: # not found, add at end of buttons buttons.append(default) # upper case it buttons[buttons.index(default)] = default.upper() # ---------------------------------------------------------------------- # add buttons to message btns_all = btn_sep.join(buttons) str_fmt = msg_fmt.format(message, btns_all) # lower everything again for compare buttons = [item.lower() for item in buttons] # ---------------------------------------------------------------------- while True: # ask the question, get the result inp = input(str_fmt) inp = inp.lower() # # no input (empty) if inp == \"\" and default != \"\": return default # input a button if inp in buttons: return inp # ------------------------------------------------------------------------------ # Compare two semantic versions # ------------------------------------------------------------------------------ def _comp_sem_ver(self, ver_old, ver_new): \"\"\" Compare two semantic versions Args: ver_old: The old version to compare ver_new: The new version to compare Returns: An integer showing the relationship between the two version Compare two semantic versions \"\"\" # sanity checks if not ver_old or ver_old == \"\": return self.S_VER_ERROR if not ver_new or ver_new == \"\": return self.S_VER_ERROR if ver_old == ver_new: return self.S_VER_SAME # -------------------------------------------------------------------------- # compare version string parts (only x.x.x) res_old = re.search(self.R_VERSION_VALID, ver_old) res_new = re.search(self.R_VERSION_VALID, ver_new) # if either version string is None if not res_old or not res_new: return self.S_VER_ERROR # make a list of groups to check lst_groups = [ self.R_VERSION_GROUP_MAJ, self.R_VERSION_GROUP_MIN, self.R_VERSION_GROUP_REV, ] # for each part as int for group in lst_groups: old_val = int(res_old.group(group)) new_val = int(res_new.group(group)) # slide out at the first difference if old_val < new_val: return self.S_VER_NEWER if old_val > new_val: return self.S_VER_OLDER # -------------------------------------------------------------------------- # still going, check pre pre_old = res_old.group(self.R_VERSION_GROUP_PRE) pre_new = res_new.group(self.R_VERSION_GROUP_PRE) # simple pre rule compare if not pre_old and pre_new: return self.S_VER_OLDER if pre_old and not pre_new: return self.S_VER_NEWER if not pre_old and not pre_new: return self.S_VER_SAME # -------------------------------------------------------------------------- # if pre_old and pre_new: # split pre on dots lst_pre_old = pre_old.split(\".\") lst_pre_new = pre_new.split(\".\") # get number of parts len_pre_old = len(lst_pre_old) len_pre_new = len(lst_pre_new) # get shorter of two shortest = len_pre_old if len_pre_old <= len_pre_new else len_pre_new # for each part in shortest for index in range(shortest): # get each value at position old_val = lst_pre_old[index] new_val = lst_pre_new[index] # 1. both numbers if old_val.isdigit() and new_val.isdigit(): tmp_old_val = int(old_val) tmp_new_val = int(new_val) # slide out at the first difference if tmp_old_val > tmp_new_val: return self.S_VER_OLDER if tmp_old_val < tmp_new_val: return self.S_VER_NEWER # 2. both alphanumeric if not old_val.isdigit() and not new_val.isdigit(): lst_alpha = [old_val, new_val] lst_alpha.sort() idx_old = lst_alpha.index(old_val) idx_new = lst_alpha.index(new_val) if idx_old > idx_new: return self.S_VER_OLDER if idx_old < idx_new: return self.S_VER_NEWER # 3 num vs alphanumeric if old_val.isdigit() and not new_val.isdigit(): return self.S_VER_OLDER if not old_val.isdigit() and new_val.isdigit(): return self.S_VER_NEWER # 4 len if len_pre_old > len_pre_new: return self.S_VER_OLDER if len_pre_new > len_pre_old: return self.S_VER_NEWER # -------------------------------------------------------------------------- # error in one or both versions return self.S_VER_ERROR","title":"CNInstall"},{"location":"API/install/install/#install.install.CNInstall.__init__","text":"Initialize the class Creates a new instance of the object and initializes its properties. Source code in install/install.py def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set arg properties self._dict_args = {} self._dry_run = False # project stuff # NB: set to path objects to avoid comparing to None self._dir_assets = Path() self._dir_usr_inst = Path() self._path_cfg_inst = Path() self._path_cfg_uninst = Path() self._dir_venv = Path() self._path_reqs = Path() self._file_desk = Path() self._file_desk_icon = Path() # config stuff self._dict_cfg = {} # cmd line stuff # NB: placeholder to avoid comparing to None self._parser = argparse.ArgumentParser()","title":"__init__"},{"location":"API/install/install/#install.install.CNInstall.main","text":"Install the program Parameters: Name Type Description Default dir_assets Path to the assets folder where all of the program required dir_usr_inst The program's install folder in which to place files required path_cfg_inst Path to the file that contains the current install required path_cfg_uninst Path to the currently installed program's required dir_venv The path to the venv folder to create required path_reqs Path to the requirements.txt file to add requirements to required file_desk Path to the .desktop file (if GUI) (default: None) None file_desk_icon Path to the .desktop file icon (if GUI) (default: None Runs the install operation. Source code in install/install.py def main( self, dir_assets, dir_usr_inst, path_cfg_inst, path_cfg_uninst, dir_venv, path_reqs, file_desk=None, file_desk_icon=None, ): \"\"\" Install the program Args: dir_assets: Path to the assets folder where all of the program files are put in dist. This is the base source path to use when copying files to the user's computer dir_usr_inst: The program's install folder in which to place files path_cfg_inst: Path to the file that contains the current install dict info path_cfg_uninst: Path to the currently installed program's uninstall dict info dir_venv: The path to the venv folder to create path_reqs: Path to the requirements.txt file to add requirements to the venv file_desk: Path to the .desktop file (if GUI) (default: None) file_desk_icon: Path to the .desktop file icon (if GUI) (default: None) Runs the install operation. \"\"\" # set props from params if dir_assets: dir_assets = Path(dir_assets) if not dir_assets.is_absolute(): # make abs rel to self dir_assets = P_DIR_PRJ / dir_assets self._dir_assets = dir_assets if dir_usr_inst: dir_usr_inst = Path(dir_usr_inst) if not dir_usr_inst.is_absolute(): # make abs rel to self dir_usr_inst = self._dir_assets / dir_usr_inst self._dir_usr_inst = dir_usr_inst if path_cfg_inst: path_cfg_inst = Path(path_cfg_inst) if not path_cfg_inst.is_absolute(): # make abs rel to self path_cfg_inst = self._dir_assets / path_cfg_inst self._path_cfg_inst = path_cfg_inst if path_cfg_uninst: path_cfg_uninst = Path(path_cfg_uninst) if not path_cfg_uninst.is_absolute(): # make abs rel to self path_cfg_uninst = self._dir_assets / path_cfg_uninst self._path_cfg_uninst = path_cfg_uninst if dir_venv: dir_venv = Path(dir_venv) if not dir_venv.is_absolute(): # make abs rel to self dir_venv = self._dir_assets / dir_venv self._dir_venv = dir_venv if path_reqs: path_reqs = Path(path_reqs) if not path_reqs.is_absolute(): # make abs rel to self path_reqs = self._dir_assets / path_reqs self._path_reqs = path_reqs if file_desk: file_desk = Path(file_desk) if not file_desk.is_absolute(): # make abs rel to self file_desk = self._dir_assets / file_desk self._file_desk = file_desk if file_desk_icon: file_desk_icon = Path(file_desk_icon) if not file_desk_icon.is_absolute(): # make abs rel to self file_desk_icon = self._dir_assets / file_desk_icon self._file_desk_icon = file_desk_icon # ---------------------------------------------------------------------- # do setup self._setup() # parse cmd line and get args self._do_cmd_line() # get prj info from cfg self._get_project_info() # check for existing/old version self._check_version() # make the venv on the user's comp self._make_venv() # install reqs self._install_reqs() # fix desktop file if present self._fix_desktop_file() # move content self._install_content() # wind down self._teardown()","title":"main"},{"location":"API/install/uninstall/","text":"uninstall.py The uninstall script for this project THis module uninstalls the project, removing its files and folders to the appropriate locations on the user's computer. This file is real ugly b/c we can't access the venv, so we do it manually. CNFormatter Bases: RawTextHelpFormatter , RawDescriptionHelpFormatter A dummy class to combine multiple argparse formatters Parameters: Name Type Description Default RawTextHelpFormatter Maintains whitespace for all sorts of help text, required RawDescriptionHelpFormatter Indicates that description and epilog are required A dummy class to combine multiple argparse formatters. Source code in install/uninstall.py class CNFormatter( argparse.RawTextHelpFormatter, argparse.RawDescriptionHelpFormatter ): \"\"\" A dummy class to combine multiple argparse formatters Args: RawTextHelpFormatter: Maintains whitespace for all sorts of help text, including argument descriptions. RawDescriptionHelpFormatter: Indicates that description and epilog are already correctly formatted and should not be line-wrapped. A dummy class to combine multiple argparse formatters. \"\"\" CNUninstall The class to use for uninstalling This class performs the uninstall operation. Source code in install/uninstall.py class CNUninstall: \"\"\" The class to use for uninstalling This class performs the uninstall operation. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # keys S_KEY_INST_NAME = \"INST_NAME\" S_KEY_INST_VER = \"INST_VER\" S_KEY_INST_DESK = \"INST_DESK\" S_KEY_INST_CONT = \"INST_CONT\" # short description S_PP_SHORT_DESC = \"Short description\" # version string S_PP_VERSION = \"0.0.2-rc1+20250823\" # debug option strings S_ARG_DRY_OPTION = \"-d\" S_ARG_DRY_ACTION = \"store_true\" S_ARG_DRY_DEST = \"DRY_DEST\" # I18N help string for debug cmd line option S_ARG_DRY_HELP = _(\"enable dry run mode\") # config option strings S_ARG_HLP_OPTION = \"-h\" S_ARG_HLP_ACTION = \"store_true\" S_ARG_HLP_DEST = \"HLP_DEST\" # I18N: help option help S_ARG_HLP_HELP = _(\"show this help message and exit\") # about string (to be set by subclass) S_ABOUT = ( \"\\n\" \"CLI_Test\\n\" f\"{S_PP_SHORT_DESC}\\n\" f\"{S_PP_VERSION}\\n\" \"https://github.com/cyclopticnerve/CLI_Test\\n\" ) # I18N if using argparse, add help at end of about S_ABOUT_HELP = _(\"Use -h for help\") # cmd line instructions string (to be set by subclass) S_EPILOG = \"\" # -------------------------------------------------------------------------- # messages # NB: format param is prog_name # I18N: uninstall the program S_MSG_UNINST_START = _(\"Uninstalling {}\") # NB: format param is prog_name # I18N: done uninstalling S_MSG_UNINST_END = _(\"{} uninstalled\") # I18N: done with step S_MSG_DONE = _(\"Done\") # I18N: step failed S_MSG_FAIL = _(\"Fail\") # I18N: show the copy step S_MSG_DEL_START = _(\"Deleting files... \") # I18N: uninstall aborted S_MSG_ABORT = _(\"Uninstallation aborted\") # questions # I18N: answer yes S_ASK_YES = _(\"y\") # I18N: answer no S_ASK_NO = _(\"n\") # NB: format param is prog name # I18N: ask to uninstall S_ASK_UNINST = _(\"This will uninstall {}.\\nDo you want to continue?\") # errors # NB: format param is file path # I18N: config file not found S_ERR_NOT_FOUND = _(\"File {} not found\") # NB: format param is file path # I18N: config file is not valid json S_ERR_NOT_JSON = _(\"File {} is not a JSON file\") # dry run messages # NB: format param is file or dir path S_DRY_REMOVE = \"\\nremove\\n{}\" # -------------------------------------------------------------------------- # Class methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the class # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set arg properties self._dict_args = {} self._dry_run = False # project stuff self._dir_usr_inst = Path() self._path_cfg_uninst = Path() # config stuff self._dict_cfg = {} # cmd line stuff # NB: placeholder to avoid comparing to None self._parser = argparse.ArgumentParser() # ------------------------------------------------------------------------------ # Uninstall the program # ------------------------------------------------------------------------------ def main(self, dir_usr_inst, path_cfg_uninst): \"\"\" Uninstall the program Args: dir_usr_inst: The program's install folder in which files are placed path_cfg_uninst: Path to the currently installed program's uninstall dict info Runs the uninstall operation. \"\"\" # set props from params if dir_usr_inst: dir_usr_inst = Path(dir_usr_inst) if not dir_usr_inst.is_absolute(): # make abs rel to self dir_usr_inst = P_DIR_PRJ / dir_usr_inst self._dir_usr_inst = dir_usr_inst if path_cfg_uninst: path_cfg_uninst = Path(path_cfg_uninst) if not path_cfg_uninst.is_absolute(): # make abs rel to self path_cfg_uninst = P_DIR_PRJ / path_cfg_uninst self._path_cfg_uninst = path_cfg_uninst # do setup self._setup() # parse cmd line and get args self._do_cmd_line() # get prj info from cfg self._get_project_info() # create an instance of the class self._uninstall_content() # wind down self._teardown() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main() # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. \"\"\" # print default about text print(self.S_ABOUT) # create a parser object in case we need it self._parser = argparse.ArgumentParser( add_help=False, epilog=self.S_EPILOG, formatter_class=CNFormatter, ) # add help text to about block print(self.S_ABOUT_HELP) # add help option self._parser.add_argument( self.S_ARG_HLP_OPTION, dest=self.S_ARG_HLP_DEST, help=self.S_ARG_HLP_HELP, action=self.S_ARG_HLP_ACTION, ) # add dry run option self._parser.add_argument( self.S_ARG_DRY_OPTION, dest=self.S_ARG_DRY_DEST, help=self.S_ARG_DRY_HELP, action=self.S_ARG_DRY_ACTION, ) # -------------------------------------------------------------------------- # Parse the arguments from the command line # -------------------------------------------------------------------------- def _do_cmd_line(self): \"\"\" Parse the arguments from the command line Parse the arguments from the command line, after the parser has been set up. \"\"\" # get namespace object args = self._parser.parse_args() # convert namespace to dict self._dict_args = vars(args) # if -h passed, this will print and exit if self._dict_args.get(self.S_ARG_HLP_DEST, False): self._parser.print_help() sys.exit() # no -h, print epilog print(self.S_EPILOG) # ---------------------------------------------------------------------- # get the args self._dry_run = self._dict_args.get(self.S_ARG_DRY_DEST, False) # -------------------------------------------------------------------------- # Get project info # -------------------------------------------------------------------------- def _get_project_info(self): \"\"\" Get project info Get the install info from the config file. \"\"\" # get project info self._dict_cfg = self._get_dict_from_file(self._path_cfg_uninst) # get prg name/version prog_name = self._dict_cfg[self.S_KEY_INST_NAME] # ask to uninstall str_ask = self._dialog( self.S_ASK_UNINST.format(prog_name), [self.S_ASK_YES, self.S_ASK_NO], self.S_ASK_NO, ) # user hit enter or typed \"n/N\" if str_ask == self.S_ASK_NO: print(self.S_MSG_ABORT) sys.exit() # print start msg print(self.S_MSG_UNINST_START.format(prog_name)) # uninstall # -------------------------------------------------------------------------- # Uninstall the program # -------------------------------------------------------------------------- def _uninstall_content(self): \"\"\" Uninstall the program Runs the uninstall operation. \"\"\" # uninstall # show some info print(self.S_MSG_DEL_START, flush=True, end=\"\") # content list from dict content = self._dict_cfg.get(self.S_KEY_INST_CONT, []) # for each key, value for item in content: # get full path of destination src = Path.home() / item # debug may omit certain assets if not src.exists(): continue # (maybe) do delete if self._dry_run: print(self.S_DRY_REMOVE.format(item)) else: # if the source is a dir if src.is_dir(): # remove dir shutil.rmtree(src) # if the source is a file else: # copy file src.unlink() # show some info print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Boilerplate to use at the end of main # -------------------------------------------------------------------------- def _teardown(self): \"\"\" Boilerplate to use at the end of main Perform some mundane stuff like saving config files. \"\"\" # just show we are done prog_name = self._dict_cfg[self.S_KEY_INST_NAME] print(self.S_MSG_UNINST_END.format(prog_name)) # -------------------------------------------------------------------------- # These are the minor steps, called from major steps for support # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Get a dict from a file # -------------------------------------------------------------------------- def _get_dict_from_file(self, a_file): \"\"\" Get a dict from a file Args: a_file: The file to load the dict from Raises: OSError if the file cannot be found or is not a valid JSON file Returns: The dict found in the file Get a dict from a file, checking if the file exists and is a valid JSON file \"\"\" # default result a_dict = {} # get dict from file try: with open(a_file, \"r\", encoding=\"UTF-8\") as a_file: a_dict = json.load(a_file) # file not found except FileNotFoundError as e: raise OSError(self.S_ERR_NOT_FOUND.format(a_file)) from e # not valid json in file except json.JSONDecodeError as e: raise OSError(self.S_ERR_NOT_JSON.format(a_file)) from e # return result return a_dict # -------------------------------------------------------------------------- # Create a dialog-like question and return the result # -------------------------------------------------------------------------- def _dialog( self, message, buttons, default=\"\", loop=False, btn_sep=\"/\", msg_fmt=\"{} [{}]: \" ): \"\"\" Create a dialog-like question and return the result Args: message: The message to display buttons: List of single char answers to the question default: The button item to return when the user presses Enter at the question (default: \"\") loop: If True and the user enters an invalid response, keep asking the question. If False, return an empty string for an invalid response (default: False) btn_sep: Char to use to separate button items msg_fmt: Format string to present message/buttons to the user Returns: A lowercased string that matches a button, or an empty string under certain conditions This method returns the string entered on the command line in response to a question. If the entered option does not match any of the buttons, the question is asked again. If you set a default and the option entered is just the Return key, the default string will be returned. If no default is present, the entered string must match one of the buttons array values. All returned values are lowercased. The question will be repeatedly printed to the screen until a valid entry is made. Note that if default == \"\", pressing Enter is not considered a valid entry. So if the default is empty and loop is True, the user MUST enter a valid response or the dialog will loop forever. \"\"\" # ---------------------------------------------------------------------- # add buttons to message btns_all = btn_sep.join(buttons) str_fmt = msg_fmt.format(message, btns_all) # ---------------------------------------------------------------------- # assume loop == True while True: # ask the question, get the result (first char only/empty) inp = input(str_fmt) if len(inp) > 0: inp = inp[0] # ---------------------------------------------------------------------- # button correct, done if inp in buttons: return inp # ---------------------------------------------------------------------- # wrong answer # default set if default != \"\": if inp == \"\": return default # no loop, return blank if not loop: return \"\" __init__() Initialize the class Creates a new instance of the object and initializes its properties. Source code in install/uninstall.py def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set arg properties self._dict_args = {} self._dry_run = False # project stuff self._dir_usr_inst = Path() self._path_cfg_uninst = Path() # config stuff self._dict_cfg = {} # cmd line stuff # NB: placeholder to avoid comparing to None self._parser = argparse.ArgumentParser() main(dir_usr_inst, path_cfg_uninst) Uninstall the program Parameters: Name Type Description Default dir_usr_inst The program's install folder in which files are required path_cfg_uninst Path to the currently installed program's required Runs the uninstall operation. Source code in install/uninstall.py def main(self, dir_usr_inst, path_cfg_uninst): \"\"\" Uninstall the program Args: dir_usr_inst: The program's install folder in which files are placed path_cfg_uninst: Path to the currently installed program's uninstall dict info Runs the uninstall operation. \"\"\" # set props from params if dir_usr_inst: dir_usr_inst = Path(dir_usr_inst) if not dir_usr_inst.is_absolute(): # make abs rel to self dir_usr_inst = P_DIR_PRJ / dir_usr_inst self._dir_usr_inst = dir_usr_inst if path_cfg_uninst: path_cfg_uninst = Path(path_cfg_uninst) if not path_cfg_uninst.is_absolute(): # make abs rel to self path_cfg_uninst = P_DIR_PRJ / path_cfg_uninst self._path_cfg_uninst = path_cfg_uninst # do setup self._setup() # parse cmd line and get args self._do_cmd_line() # get prj info from cfg self._get_project_info() # create an instance of the class self._uninstall_content() # wind down self._teardown()","title":"uninstall.py"},{"location":"API/install/uninstall/#uninstallpy","text":"The uninstall script for this project THis module uninstalls the project, removing its files and folders to the appropriate locations on the user's computer. This file is real ugly b/c we can't access the venv, so we do it manually.","title":"uninstall.py"},{"location":"API/install/uninstall/#install.uninstall.CNFormatter","text":"Bases: RawTextHelpFormatter , RawDescriptionHelpFormatter A dummy class to combine multiple argparse formatters Parameters: Name Type Description Default RawTextHelpFormatter Maintains whitespace for all sorts of help text, required RawDescriptionHelpFormatter Indicates that description and epilog are required A dummy class to combine multiple argparse formatters. Source code in install/uninstall.py class CNFormatter( argparse.RawTextHelpFormatter, argparse.RawDescriptionHelpFormatter ): \"\"\" A dummy class to combine multiple argparse formatters Args: RawTextHelpFormatter: Maintains whitespace for all sorts of help text, including argument descriptions. RawDescriptionHelpFormatter: Indicates that description and epilog are already correctly formatted and should not be line-wrapped. A dummy class to combine multiple argparse formatters. \"\"\"","title":"CNFormatter"},{"location":"API/install/uninstall/#install.uninstall.CNUninstall","text":"The class to use for uninstalling This class performs the uninstall operation. Source code in install/uninstall.py class CNUninstall: \"\"\" The class to use for uninstalling This class performs the uninstall operation. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # keys S_KEY_INST_NAME = \"INST_NAME\" S_KEY_INST_VER = \"INST_VER\" S_KEY_INST_DESK = \"INST_DESK\" S_KEY_INST_CONT = \"INST_CONT\" # short description S_PP_SHORT_DESC = \"Short description\" # version string S_PP_VERSION = \"0.0.2-rc1+20250823\" # debug option strings S_ARG_DRY_OPTION = \"-d\" S_ARG_DRY_ACTION = \"store_true\" S_ARG_DRY_DEST = \"DRY_DEST\" # I18N help string for debug cmd line option S_ARG_DRY_HELP = _(\"enable dry run mode\") # config option strings S_ARG_HLP_OPTION = \"-h\" S_ARG_HLP_ACTION = \"store_true\" S_ARG_HLP_DEST = \"HLP_DEST\" # I18N: help option help S_ARG_HLP_HELP = _(\"show this help message and exit\") # about string (to be set by subclass) S_ABOUT = ( \"\\n\" \"CLI_Test\\n\" f\"{S_PP_SHORT_DESC}\\n\" f\"{S_PP_VERSION}\\n\" \"https://github.com/cyclopticnerve/CLI_Test\\n\" ) # I18N if using argparse, add help at end of about S_ABOUT_HELP = _(\"Use -h for help\") # cmd line instructions string (to be set by subclass) S_EPILOG = \"\" # -------------------------------------------------------------------------- # messages # NB: format param is prog_name # I18N: uninstall the program S_MSG_UNINST_START = _(\"Uninstalling {}\") # NB: format param is prog_name # I18N: done uninstalling S_MSG_UNINST_END = _(\"{} uninstalled\") # I18N: done with step S_MSG_DONE = _(\"Done\") # I18N: step failed S_MSG_FAIL = _(\"Fail\") # I18N: show the copy step S_MSG_DEL_START = _(\"Deleting files... \") # I18N: uninstall aborted S_MSG_ABORT = _(\"Uninstallation aborted\") # questions # I18N: answer yes S_ASK_YES = _(\"y\") # I18N: answer no S_ASK_NO = _(\"n\") # NB: format param is prog name # I18N: ask to uninstall S_ASK_UNINST = _(\"This will uninstall {}.\\nDo you want to continue?\") # errors # NB: format param is file path # I18N: config file not found S_ERR_NOT_FOUND = _(\"File {} not found\") # NB: format param is file path # I18N: config file is not valid json S_ERR_NOT_JSON = _(\"File {} is not a JSON file\") # dry run messages # NB: format param is file or dir path S_DRY_REMOVE = \"\\nremove\\n{}\" # -------------------------------------------------------------------------- # Class methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the class # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set arg properties self._dict_args = {} self._dry_run = False # project stuff self._dir_usr_inst = Path() self._path_cfg_uninst = Path() # config stuff self._dict_cfg = {} # cmd line stuff # NB: placeholder to avoid comparing to None self._parser = argparse.ArgumentParser() # ------------------------------------------------------------------------------ # Uninstall the program # ------------------------------------------------------------------------------ def main(self, dir_usr_inst, path_cfg_uninst): \"\"\" Uninstall the program Args: dir_usr_inst: The program's install folder in which files are placed path_cfg_uninst: Path to the currently installed program's uninstall dict info Runs the uninstall operation. \"\"\" # set props from params if dir_usr_inst: dir_usr_inst = Path(dir_usr_inst) if not dir_usr_inst.is_absolute(): # make abs rel to self dir_usr_inst = P_DIR_PRJ / dir_usr_inst self._dir_usr_inst = dir_usr_inst if path_cfg_uninst: path_cfg_uninst = Path(path_cfg_uninst) if not path_cfg_uninst.is_absolute(): # make abs rel to self path_cfg_uninst = P_DIR_PRJ / path_cfg_uninst self._path_cfg_uninst = path_cfg_uninst # do setup self._setup() # parse cmd line and get args self._do_cmd_line() # get prj info from cfg self._get_project_info() # create an instance of the class self._uninstall_content() # wind down self._teardown() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # NB: these are the main steps, called in order from main() # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like setting properties. \"\"\" # print default about text print(self.S_ABOUT) # create a parser object in case we need it self._parser = argparse.ArgumentParser( add_help=False, epilog=self.S_EPILOG, formatter_class=CNFormatter, ) # add help text to about block print(self.S_ABOUT_HELP) # add help option self._parser.add_argument( self.S_ARG_HLP_OPTION, dest=self.S_ARG_HLP_DEST, help=self.S_ARG_HLP_HELP, action=self.S_ARG_HLP_ACTION, ) # add dry run option self._parser.add_argument( self.S_ARG_DRY_OPTION, dest=self.S_ARG_DRY_DEST, help=self.S_ARG_DRY_HELP, action=self.S_ARG_DRY_ACTION, ) # -------------------------------------------------------------------------- # Parse the arguments from the command line # -------------------------------------------------------------------------- def _do_cmd_line(self): \"\"\" Parse the arguments from the command line Parse the arguments from the command line, after the parser has been set up. \"\"\" # get namespace object args = self._parser.parse_args() # convert namespace to dict self._dict_args = vars(args) # if -h passed, this will print and exit if self._dict_args.get(self.S_ARG_HLP_DEST, False): self._parser.print_help() sys.exit() # no -h, print epilog print(self.S_EPILOG) # ---------------------------------------------------------------------- # get the args self._dry_run = self._dict_args.get(self.S_ARG_DRY_DEST, False) # -------------------------------------------------------------------------- # Get project info # -------------------------------------------------------------------------- def _get_project_info(self): \"\"\" Get project info Get the install info from the config file. \"\"\" # get project info self._dict_cfg = self._get_dict_from_file(self._path_cfg_uninst) # get prg name/version prog_name = self._dict_cfg[self.S_KEY_INST_NAME] # ask to uninstall str_ask = self._dialog( self.S_ASK_UNINST.format(prog_name), [self.S_ASK_YES, self.S_ASK_NO], self.S_ASK_NO, ) # user hit enter or typed \"n/N\" if str_ask == self.S_ASK_NO: print(self.S_MSG_ABORT) sys.exit() # print start msg print(self.S_MSG_UNINST_START.format(prog_name)) # uninstall # -------------------------------------------------------------------------- # Uninstall the program # -------------------------------------------------------------------------- def _uninstall_content(self): \"\"\" Uninstall the program Runs the uninstall operation. \"\"\" # uninstall # show some info print(self.S_MSG_DEL_START, flush=True, end=\"\") # content list from dict content = self._dict_cfg.get(self.S_KEY_INST_CONT, []) # for each key, value for item in content: # get full path of destination src = Path.home() / item # debug may omit certain assets if not src.exists(): continue # (maybe) do delete if self._dry_run: print(self.S_DRY_REMOVE.format(item)) else: # if the source is a dir if src.is_dir(): # remove dir shutil.rmtree(src) # if the source is a file else: # copy file src.unlink() # show some info print(self.S_MSG_DONE) # -------------------------------------------------------------------------- # Boilerplate to use at the end of main # -------------------------------------------------------------------------- def _teardown(self): \"\"\" Boilerplate to use at the end of main Perform some mundane stuff like saving config files. \"\"\" # just show we are done prog_name = self._dict_cfg[self.S_KEY_INST_NAME] print(self.S_MSG_UNINST_END.format(prog_name)) # -------------------------------------------------------------------------- # These are the minor steps, called from major steps for support # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Get a dict from a file # -------------------------------------------------------------------------- def _get_dict_from_file(self, a_file): \"\"\" Get a dict from a file Args: a_file: The file to load the dict from Raises: OSError if the file cannot be found or is not a valid JSON file Returns: The dict found in the file Get a dict from a file, checking if the file exists and is a valid JSON file \"\"\" # default result a_dict = {} # get dict from file try: with open(a_file, \"r\", encoding=\"UTF-8\") as a_file: a_dict = json.load(a_file) # file not found except FileNotFoundError as e: raise OSError(self.S_ERR_NOT_FOUND.format(a_file)) from e # not valid json in file except json.JSONDecodeError as e: raise OSError(self.S_ERR_NOT_JSON.format(a_file)) from e # return result return a_dict # -------------------------------------------------------------------------- # Create a dialog-like question and return the result # -------------------------------------------------------------------------- def _dialog( self, message, buttons, default=\"\", loop=False, btn_sep=\"/\", msg_fmt=\"{} [{}]: \" ): \"\"\" Create a dialog-like question and return the result Args: message: The message to display buttons: List of single char answers to the question default: The button item to return when the user presses Enter at the question (default: \"\") loop: If True and the user enters an invalid response, keep asking the question. If False, return an empty string for an invalid response (default: False) btn_sep: Char to use to separate button items msg_fmt: Format string to present message/buttons to the user Returns: A lowercased string that matches a button, or an empty string under certain conditions This method returns the string entered on the command line in response to a question. If the entered option does not match any of the buttons, the question is asked again. If you set a default and the option entered is just the Return key, the default string will be returned. If no default is present, the entered string must match one of the buttons array values. All returned values are lowercased. The question will be repeatedly printed to the screen until a valid entry is made. Note that if default == \"\", pressing Enter is not considered a valid entry. So if the default is empty and loop is True, the user MUST enter a valid response or the dialog will loop forever. \"\"\" # ---------------------------------------------------------------------- # add buttons to message btns_all = btn_sep.join(buttons) str_fmt = msg_fmt.format(message, btns_all) # ---------------------------------------------------------------------- # assume loop == True while True: # ask the question, get the result (first char only/empty) inp = input(str_fmt) if len(inp) > 0: inp = inp[0] # ---------------------------------------------------------------------- # button correct, done if inp in buttons: return inp # ---------------------------------------------------------------------- # wrong answer # default set if default != \"\": if inp == \"\": return default # no loop, return blank if not loop: return \"\"","title":"CNUninstall"},{"location":"API/install/uninstall/#install.uninstall.CNUninstall.__init__","text":"Initialize the class Creates a new instance of the object and initializes its properties. Source code in install/uninstall.py def __init__(self): \"\"\" Initialize the class Creates a new instance of the object and initializes its properties. \"\"\" # set arg properties self._dict_args = {} self._dry_run = False # project stuff self._dir_usr_inst = Path() self._path_cfg_uninst = Path() # config stuff self._dict_cfg = {} # cmd line stuff # NB: placeholder to avoid comparing to None self._parser = argparse.ArgumentParser()","title":"__init__"},{"location":"API/install/uninstall/#install.uninstall.CNUninstall.main","text":"Uninstall the program Parameters: Name Type Description Default dir_usr_inst The program's install folder in which files are required path_cfg_uninst Path to the currently installed program's required Runs the uninstall operation. Source code in install/uninstall.py def main(self, dir_usr_inst, path_cfg_uninst): \"\"\" Uninstall the program Args: dir_usr_inst: The program's install folder in which files are placed path_cfg_uninst: Path to the currently installed program's uninstall dict info Runs the uninstall operation. \"\"\" # set props from params if dir_usr_inst: dir_usr_inst = Path(dir_usr_inst) if not dir_usr_inst.is_absolute(): # make abs rel to self dir_usr_inst = P_DIR_PRJ / dir_usr_inst self._dir_usr_inst = dir_usr_inst if path_cfg_uninst: path_cfg_uninst = Path(path_cfg_uninst) if not path_cfg_uninst.is_absolute(): # make abs rel to self path_cfg_uninst = P_DIR_PRJ / path_cfg_uninst self._path_cfg_uninst = path_cfg_uninst # do setup self._setup() # parse cmd line and get args self._do_cmd_line() # get prj info from cfg self._get_project_info() # create an instance of the class self._uninstall_content() # wind down self._teardown()","title":"main"},{"location":"API/src/cli_test/","text":"cli_test.py The main file that runs the program This file is executable and can be called from the terminal like: foo@bar:~$ cd [path to directory of this file] foo@bar:~[path to directory of this file]$ ./cli_test.py [cmd line] or if installed in a global location: foo@bar:~$ cli_test [cmd line] Typical usage is show in the main() method. CliTest The main class, responsible for the operation of the program Public methods main: The main method of the program This class does the most of the work of a typical CLI program. It parses command line options, loads/saves config files, and performs the operations required for the program. Source code in src/cli_test.py class CliTest: \"\"\" The main class, responsible for the operation of the program Public methods: main: The main method of the program This class does the most of the work of a typical CLI program. It parses command line options, loads/saves config files, and performs the operations required for the program. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # find path to project P_DIR_PRJ = Path(__file__).parents[1].resolve() # -------------------------------------------------------------------------- # short description S_PP_SHORT_DESC = \"Short description\" # version string S_PP_VERSION = \"0.0.2-rc1+20250823\" # config option strings S_ARG_CFG_OPTION = \"-c\" S_ARG_CFG_DEST = \"CFG_DEST\" # I18N: config file option help S_ARG_CFG_HELP = _(\"load configuration from file\") # I18N: config file dest S_ARG_CFG_METAVAR = _(\"FILE\") # debug option strings S_ARG_DBG_OPTION = \"-d\" S_ARG_DBG_ACTION = \"store_true\" S_ARG_DBG_DEST = \"DBG_DEST\" # I18N: debug mode help S_ARG_DBG_HELP = _(\"enable debugging mode\") # config option strings S_ARG_HLP_OPTION = \"-h\" S_ARG_HLP_ACTION = \"store_true\" S_ARG_HLP_DEST = \"HLP_DEST\" # I18N: help option help S_ARG_HLP_HELP = _(\"show this help message and exit\") # config option strings S_ARG_UNINST_OPTION = \"--uninstall\" S_ARG_UNINST_ACTION = \"store_true\" S_ARG_UNINST_DEST = \"UNINST_DEST\" # I18N: uninstall option help S_ARG_UNINST_HELP = _(\"uninstall this program\") # about string S_ABOUT = ( \"\\n\" \"CLI_Test\\n\" f\"{S_PP_SHORT_DESC}\\n\" f\"{S_PP_VERSION}\\n\" \"https://github.com/cyclopticnerve/CLI_Test\\n\" ) # I18N if using argparse, add help at end of about S_ABOUT_HELP = _(\"Use -h for help\") + \"\\n\" # path to default config file P_CFG_DEF = Path(\"conf/cli_test.json\") # uninst not found # I18N: uninstall not found S_ERR_NO_UNINST = _(\"Uninstall files not found\") # -------------------------------------------------------------------------- # Instance methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set defaults # cmd line args self._dict_args = {} self._debug = False self._path_cfg_arg = None # the final cfg path and dict self._path_cfg = None self._dict_cfg = {} # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # ---------------------------------------------------------------------- # setup # call boilerplate code self._setup() # ---------------------------------------------------------------------- # main stuff # do the thing with the thing print(self._func()) # ---------------------------------------------------------------------- # teardown # call boilerplate code self._teardown() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Short description # -------------------------------------------------------------------------- def _func(self): \"\"\" Short description Args: var_name: Short description Returns: Description Raises: exception_type(vars): Description Long description (including HTML). \"\"\" # check for debug flag if self._debug: # I18N: context for this string return _(\"this is func (DEBUG)\") # no debug, return normal result # I18N: context for this string return _(\"this is func\") # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like running the arg parser and loading config files. \"\"\" # print default about text print(self.S_ABOUT) # ---------------------------------------------------------------------- # use cmd line # create a parser object in case we need it parser = argparse.ArgumentParser( formatter_class=CNFormatter, add_help=False ) # add help text to about block print(self.S_ABOUT_HELP) # add cfg option parser.add_argument( self.S_ARG_CFG_OPTION, dest=self.S_ARG_CFG_DEST, help=self.S_ARG_CFG_HELP, metavar=self.S_ARG_CFG_METAVAR, ) # add debug option parser.add_argument( self.S_ARG_DBG_OPTION, action=self.S_ARG_DBG_ACTION, dest=self.S_ARG_DBG_DEST, help=self.S_ARG_DBG_HELP, ) # add help option parser.add_argument( self.S_ARG_HLP_OPTION, action=self.S_ARG_HLP_ACTION, dest=self.S_ARG_HLP_DEST, help=self.S_ARG_HLP_HELP, ) # add help option parser.add_argument( self.S_ARG_UNINST_OPTION, action=self.S_ARG_UNINST_ACTION, dest=self.S_ARG_UNINST_DEST, help=self.S_ARG_UNINST_HELP, ) # run the parser args = parser.parse_args() self._dict_args = vars(args) # if -h passed, this will print and exit if self._dict_args.get(self.S_ARG_HLP_DEST, False): parser.print_help() print() sys.exit() # set props from args self._debug = self._dict_args.get(self.S_ARG_DBG_DEST, self._debug) self._path_cfg_arg = self._dict_args.get( self.S_ARG_CFG_DEST, self._path_cfg_arg ) # punt to sub func if self._dict_args.get(self.S_ARG_UNINST_DEST, False): self._do_uninstall() # ---------------------------------------------------------------------- # use cfg # fix paths and get cfg to load self._get_path_cfg() # load config file (or not, if no param and not using -c) self._load_config() # -------------------------------------------------------------------------- # Boilerplate to use at the end of main # -------------------------------------------------------------------------- def _teardown(self): \"\"\" Boilerplate to use at the end of main Perform some mundane stuff like saving config files. \"\"\" # ---------------------------------------------------------------------- # use cfg # call to save config self._save_config() # -------------------------------------------------------------------------- # Get path to config file from cmd line option or default # -------------------------------------------------------------------------- def _get_path_cfg(self): \"\"\" Get path to config file from cmd line option or default This method figures the config path from either: 1. the command line -c option (if present) or 2. the self.P_CFG_DEF value (if present) If you use the -c option, and the file exists, it will used as the _path_cfg property, and processing stops. If you do not use the -c option, or it is not present on the command line, the path_def value will be used. If you use neither, nothing happens to the _path_cfg property. \"\"\" # accept path or str path_def = self.P_CFG_DEF if path_def: path_def = Path(path_def) if not path_def.is_absolute(): # make abs rel to self path_def = self.P_DIR_PRJ / path_def # accept path or str if self._path_cfg_arg: self._path_cfg_arg = Path(self._path_cfg_arg) if not self._path_cfg_arg.is_absolute(): # make abs rel to self self._path_cfg_arg = self.P_DIR_PRJ / self._path_cfg_arg # ---------------------------------------------------------------------- # assume def if path_def: self._path_cfg = path_def # arg supersedes def if self._path_cfg_arg: self._path_cfg = self._path_cfg_arg # -------------------------------------------------------------------------- # Load config data from a file # -------------------------------------------------------------------------- def _load_config(self): \"\"\" Load config data from a file This method loads data from a config file. It is written to load a dict from a json file, but it can be used for other formats as well. It uses the values of self._dict_cfg and self._path_cfg to load the config data. \"\"\" # if one or the other, load it if self._path_cfg and self._path_cfg.exists(): self._dict_cfg = F.load_dicts([self._path_cfg], self._dict_cfg) # throw in a debug test if self._debug: print(\"load cfg from:\", self._path_cfg) F.pp(self._dict_cfg, label=\"load cfg\") # -------------------------------------------------------------------------- # Save config data to a file # -------------------------------------------------------------------------- def _save_config(self): \"\"\" Save config data to a file This method saves the config data to the same file it was loaded from. It is written to save a dict to a json file, but it can be used for other formats as well. It uses the values of self._dict_cfg and self._path_cfg to save the config data. \"\"\" # save dict to path if self._path_cfg: self._path_cfg.parent.mkdir(parents=True, exist_ok=True) F.save_dict(self._dict_cfg, [self._path_cfg]) # throw in a debug test if self._debug: print(\"save cfg to:\", self._path_cfg) F.pp(self._dict_cfg, label=\"save cfg\") # -------------------------------------------------------------------------- # Handle the --uninstall cmd line op # -------------------------------------------------------------------------- def _do_uninstall(self): \"\"\" Handle the -- uninstall cmd line op \"\"\" # find uninstall file path_uninst = Path.home() / \".local/share/cli_test/uninstall.py\" # if path exists if path_uninst.exists(): # run uninstall and exit cmd = str(path_uninst) subprocess.run(cmd, shell=True, check=True) sys.exit() else: print(self.S_ERR_NO_UNINST) sys.exit() __init__() Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. Source code in src/cli_test.py def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set defaults # cmd line args self._dict_args = {} self._debug = False self._path_cfg_arg = None # the final cfg path and dict self._path_cfg = None self._dict_cfg = {} main() The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. Source code in src/cli_test.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # ---------------------------------------------------------------------- # setup # call boilerplate code self._setup() # ---------------------------------------------------------------------- # main stuff # do the thing with the thing print(self._func()) # ---------------------------------------------------------------------- # teardown # call boilerplate code self._teardown()","title":"cli_test.py"},{"location":"API/src/cli_test/#cli_testpy","text":"The main file that runs the program This file is executable and can be called from the terminal like: foo@bar:~$ cd [path to directory of this file] foo@bar:~[path to directory of this file]$ ./cli_test.py [cmd line] or if installed in a global location: foo@bar:~$ cli_test [cmd line] Typical usage is show in the main() method.","title":"cli_test.py"},{"location":"API/src/cli_test/#src.cli_test.CliTest","text":"The main class, responsible for the operation of the program Public methods main: The main method of the program This class does the most of the work of a typical CLI program. It parses command line options, loads/saves config files, and performs the operations required for the program. Source code in src/cli_test.py class CliTest: \"\"\" The main class, responsible for the operation of the program Public methods: main: The main method of the program This class does the most of the work of a typical CLI program. It parses command line options, loads/saves config files, and performs the operations required for the program. \"\"\" # -------------------------------------------------------------------------- # Class constants # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # find path to project P_DIR_PRJ = Path(__file__).parents[1].resolve() # -------------------------------------------------------------------------- # short description S_PP_SHORT_DESC = \"Short description\" # version string S_PP_VERSION = \"0.0.2-rc1+20250823\" # config option strings S_ARG_CFG_OPTION = \"-c\" S_ARG_CFG_DEST = \"CFG_DEST\" # I18N: config file option help S_ARG_CFG_HELP = _(\"load configuration from file\") # I18N: config file dest S_ARG_CFG_METAVAR = _(\"FILE\") # debug option strings S_ARG_DBG_OPTION = \"-d\" S_ARG_DBG_ACTION = \"store_true\" S_ARG_DBG_DEST = \"DBG_DEST\" # I18N: debug mode help S_ARG_DBG_HELP = _(\"enable debugging mode\") # config option strings S_ARG_HLP_OPTION = \"-h\" S_ARG_HLP_ACTION = \"store_true\" S_ARG_HLP_DEST = \"HLP_DEST\" # I18N: help option help S_ARG_HLP_HELP = _(\"show this help message and exit\") # config option strings S_ARG_UNINST_OPTION = \"--uninstall\" S_ARG_UNINST_ACTION = \"store_true\" S_ARG_UNINST_DEST = \"UNINST_DEST\" # I18N: uninstall option help S_ARG_UNINST_HELP = _(\"uninstall this program\") # about string S_ABOUT = ( \"\\n\" \"CLI_Test\\n\" f\"{S_PP_SHORT_DESC}\\n\" f\"{S_PP_VERSION}\\n\" \"https://github.com/cyclopticnerve/CLI_Test\\n\" ) # I18N if using argparse, add help at end of about S_ABOUT_HELP = _(\"Use -h for help\") + \"\\n\" # path to default config file P_CFG_DEF = Path(\"conf/cli_test.json\") # uninst not found # I18N: uninstall not found S_ERR_NO_UNINST = _(\"Uninstall files not found\") # -------------------------------------------------------------------------- # Instance methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Initialize the new object # -------------------------------------------------------------------------- def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set defaults # cmd line args self._dict_args = {} self._debug = False self._path_cfg_arg = None # the final cfg path and dict self._path_cfg = None self._dict_cfg = {} # -------------------------------------------------------------------------- # Public methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # The main method of the program # -------------------------------------------------------------------------- def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # ---------------------------------------------------------------------- # setup # call boilerplate code self._setup() # ---------------------------------------------------------------------- # main stuff # do the thing with the thing print(self._func()) # ---------------------------------------------------------------------- # teardown # call boilerplate code self._teardown() # -------------------------------------------------------------------------- # Private methods # -------------------------------------------------------------------------- # -------------------------------------------------------------------------- # Short description # -------------------------------------------------------------------------- def _func(self): \"\"\" Short description Args: var_name: Short description Returns: Description Raises: exception_type(vars): Description Long description (including HTML). \"\"\" # check for debug flag if self._debug: # I18N: context for this string return _(\"this is func (DEBUG)\") # no debug, return normal result # I18N: context for this string return _(\"this is func\") # -------------------------------------------------------------------------- # Boilerplate to use at the start of main # -------------------------------------------------------------------------- def _setup(self): \"\"\" Boilerplate to use at the start of main Perform some mundane stuff like running the arg parser and loading config files. \"\"\" # print default about text print(self.S_ABOUT) # ---------------------------------------------------------------------- # use cmd line # create a parser object in case we need it parser = argparse.ArgumentParser( formatter_class=CNFormatter, add_help=False ) # add help text to about block print(self.S_ABOUT_HELP) # add cfg option parser.add_argument( self.S_ARG_CFG_OPTION, dest=self.S_ARG_CFG_DEST, help=self.S_ARG_CFG_HELP, metavar=self.S_ARG_CFG_METAVAR, ) # add debug option parser.add_argument( self.S_ARG_DBG_OPTION, action=self.S_ARG_DBG_ACTION, dest=self.S_ARG_DBG_DEST, help=self.S_ARG_DBG_HELP, ) # add help option parser.add_argument( self.S_ARG_HLP_OPTION, action=self.S_ARG_HLP_ACTION, dest=self.S_ARG_HLP_DEST, help=self.S_ARG_HLP_HELP, ) # add help option parser.add_argument( self.S_ARG_UNINST_OPTION, action=self.S_ARG_UNINST_ACTION, dest=self.S_ARG_UNINST_DEST, help=self.S_ARG_UNINST_HELP, ) # run the parser args = parser.parse_args() self._dict_args = vars(args) # if -h passed, this will print and exit if self._dict_args.get(self.S_ARG_HLP_DEST, False): parser.print_help() print() sys.exit() # set props from args self._debug = self._dict_args.get(self.S_ARG_DBG_DEST, self._debug) self._path_cfg_arg = self._dict_args.get( self.S_ARG_CFG_DEST, self._path_cfg_arg ) # punt to sub func if self._dict_args.get(self.S_ARG_UNINST_DEST, False): self._do_uninstall() # ---------------------------------------------------------------------- # use cfg # fix paths and get cfg to load self._get_path_cfg() # load config file (or not, if no param and not using -c) self._load_config() # -------------------------------------------------------------------------- # Boilerplate to use at the end of main # -------------------------------------------------------------------------- def _teardown(self): \"\"\" Boilerplate to use at the end of main Perform some mundane stuff like saving config files. \"\"\" # ---------------------------------------------------------------------- # use cfg # call to save config self._save_config() # -------------------------------------------------------------------------- # Get path to config file from cmd line option or default # -------------------------------------------------------------------------- def _get_path_cfg(self): \"\"\" Get path to config file from cmd line option or default This method figures the config path from either: 1. the command line -c option (if present) or 2. the self.P_CFG_DEF value (if present) If you use the -c option, and the file exists, it will used as the _path_cfg property, and processing stops. If you do not use the -c option, or it is not present on the command line, the path_def value will be used. If you use neither, nothing happens to the _path_cfg property. \"\"\" # accept path or str path_def = self.P_CFG_DEF if path_def: path_def = Path(path_def) if not path_def.is_absolute(): # make abs rel to self path_def = self.P_DIR_PRJ / path_def # accept path or str if self._path_cfg_arg: self._path_cfg_arg = Path(self._path_cfg_arg) if not self._path_cfg_arg.is_absolute(): # make abs rel to self self._path_cfg_arg = self.P_DIR_PRJ / self._path_cfg_arg # ---------------------------------------------------------------------- # assume def if path_def: self._path_cfg = path_def # arg supersedes def if self._path_cfg_arg: self._path_cfg = self._path_cfg_arg # -------------------------------------------------------------------------- # Load config data from a file # -------------------------------------------------------------------------- def _load_config(self): \"\"\" Load config data from a file This method loads data from a config file. It is written to load a dict from a json file, but it can be used for other formats as well. It uses the values of self._dict_cfg and self._path_cfg to load the config data. \"\"\" # if one or the other, load it if self._path_cfg and self._path_cfg.exists(): self._dict_cfg = F.load_dicts([self._path_cfg], self._dict_cfg) # throw in a debug test if self._debug: print(\"load cfg from:\", self._path_cfg) F.pp(self._dict_cfg, label=\"load cfg\") # -------------------------------------------------------------------------- # Save config data to a file # -------------------------------------------------------------------------- def _save_config(self): \"\"\" Save config data to a file This method saves the config data to the same file it was loaded from. It is written to save a dict to a json file, but it can be used for other formats as well. It uses the values of self._dict_cfg and self._path_cfg to save the config data. \"\"\" # save dict to path if self._path_cfg: self._path_cfg.parent.mkdir(parents=True, exist_ok=True) F.save_dict(self._dict_cfg, [self._path_cfg]) # throw in a debug test if self._debug: print(\"save cfg to:\", self._path_cfg) F.pp(self._dict_cfg, label=\"save cfg\") # -------------------------------------------------------------------------- # Handle the --uninstall cmd line op # -------------------------------------------------------------------------- def _do_uninstall(self): \"\"\" Handle the -- uninstall cmd line op \"\"\" # find uninstall file path_uninst = Path.home() / \".local/share/cli_test/uninstall.py\" # if path exists if path_uninst.exists(): # run uninstall and exit cmd = str(path_uninst) subprocess.run(cmd, shell=True, check=True) sys.exit() else: print(self.S_ERR_NO_UNINST) sys.exit()","title":"CliTest"},{"location":"API/src/cli_test/#src.cli_test.CliTest.__init__","text":"Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. Source code in src/cli_test.py def __init__(self): \"\"\" Initialize the new object Initializes a new instance of the class, setting the default values of its properties, and any other code that needs to run to create a new object. \"\"\" # set defaults # cmd line args self._dict_args = {} self._debug = False self._path_cfg_arg = None # the final cfg path and dict self._path_cfg = None self._dict_cfg = {}","title":"__init__"},{"location":"API/src/cli_test/#src.cli_test.CliTest.main","text":"The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. Source code in src/cli_test.py def main(self): \"\"\" The main method of the program This method is the main entry point for the program, initializing the program, and performing its steps. \"\"\" # ---------------------------------------------------------------------- # setup # call boilerplate code self._setup() # ---------------------------------------------------------------------- # main stuff # do the thing with the thing print(self._func()) # ---------------------------------------------------------------------- # teardown # call boilerplate code self._teardown()","title":"main"}]}